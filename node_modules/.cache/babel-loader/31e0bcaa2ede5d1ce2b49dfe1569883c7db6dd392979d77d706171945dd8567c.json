{"ast":null,"code":"import { validateAndCoerceTypebox } from \"../lib/validateAndCoerceTypes.js\";\nimport quote, { QuoteOptionsSchema } from \"../modules/quote.js\";\nconst DEBOUNCE_TIME = 50;\nconst slugMap = new Map();\nexport default function quoteCombine(query, queryOptionsOverrides = {}, moduleOptions) {\n  const symbol = query;\n  if (typeof symbol !== \"string\") throw new Error(\"quoteCombine expects a string query parameter, received: \" + JSON.stringify(symbol, null, 2));\n  validateAndCoerceTypebox({\n    type: \"options\",\n    data: queryOptionsOverrides,\n    schema: QuoteOptionsSchema,\n    options: this._opts.validation\n  });\n  // Make sure we only combine requests with same options\n  const slug = JSON.stringify(queryOptionsOverrides);\n  let entry = slugMap.get(slug);\n  if (!entry) {\n    entry = {\n      timeout: null,\n      queryOptionsOverrides,\n      symbols: new Map()\n    };\n    slugMap.set(slug, entry);\n  }\n  if (entry.timeout) clearTimeout(entry.timeout);\n  const thisQuote = quote.bind(this);\n  return new Promise((resolve, reject) => {\n    let symbolPromiseCallbacks = entry.symbols.get(symbol);\n    /* istanbul ignore else */\n    if (!symbolPromiseCallbacks) {\n      symbolPromiseCallbacks = [];\n      entry.symbols.set(symbol, symbolPromiseCallbacks);\n    }\n    symbolPromiseCallbacks.push({\n      resolve,\n      reject\n    });\n    entry.timeout = setTimeout(() => {\n      slugMap.delete(slug);\n      const symbols = Array.from(entry.symbols.keys());\n      // @ts-ignore\n      thisQuote(symbols, queryOptionsOverrides, moduleOptions).then(results => {\n        for (const result of results) {\n          for (const promise of entry.symbols.get(result.symbol)) {\n            promise.resolve(result);\n            promise.resolved = true;\n          }\n        }\n        // Check for symbols we asked for and didn't get back,\n        // e.g. non-existent symbols (#150)\n        for (const [_, promises] of entry.symbols) {\n          for (const promise of promises) {\n            if (!promise.resolved) {\n              promise.resolve(undefined);\n            }\n          }\n        }\n      }).catch(error => {\n        for (const symbolPromiseCallbacks of entry.symbols.values()) for (const promise of symbolPromiseCallbacks) promise.reject(error);\n      });\n    }, DEBOUNCE_TIME);\n  });\n}","map":{"version":3,"names":["validateAndCoerceTypebox","quote","QuoteOptionsSchema","DEBOUNCE_TIME","slugMap","Map","quoteCombine","query","queryOptionsOverrides","moduleOptions","symbol","Error","JSON","stringify","type","data","schema","options","_opts","validation","slug","entry","get","timeout","symbols","set","clearTimeout","thisQuote","bind","Promise","resolve","reject","symbolPromiseCallbacks","push","setTimeout","delete","Array","from","keys","then","results","result","promise","resolved","_","promises","undefined","catch","error","values"],"sources":["C:/Users/ordon/ThetaFlowz_Cursor/node_modules/yahoo-finance2/dist/esm/src/other/quoteCombine.js"],"sourcesContent":["import { validateAndCoerceTypebox } from \"../lib/validateAndCoerceTypes.js\";\nimport quote, { QuoteOptionsSchema } from \"../modules/quote.js\";\nconst DEBOUNCE_TIME = 50;\nconst slugMap = new Map();\nexport default function quoteCombine(query, queryOptionsOverrides = {}, moduleOptions) {\n    const symbol = query;\n    if (typeof symbol !== \"string\")\n        throw new Error(\"quoteCombine expects a string query parameter, received: \" +\n            JSON.stringify(symbol, null, 2));\n    validateAndCoerceTypebox({\n        type: \"options\",\n        data: queryOptionsOverrides,\n        schema: QuoteOptionsSchema,\n        options: this._opts.validation,\n    });\n    // Make sure we only combine requests with same options\n    const slug = JSON.stringify(queryOptionsOverrides);\n    let entry = slugMap.get(slug);\n    if (!entry) {\n        entry = {\n            timeout: null,\n            queryOptionsOverrides,\n            symbols: new Map(),\n        };\n        slugMap.set(slug, entry);\n    }\n    if (entry.timeout)\n        clearTimeout(entry.timeout);\n    const thisQuote = quote.bind(this);\n    return new Promise((resolve, reject) => {\n        let symbolPromiseCallbacks = entry.symbols.get(symbol);\n        /* istanbul ignore else */\n        if (!symbolPromiseCallbacks) {\n            symbolPromiseCallbacks = [];\n            entry.symbols.set(symbol, symbolPromiseCallbacks);\n        }\n        symbolPromiseCallbacks.push({ resolve, reject });\n        entry.timeout = setTimeout(() => {\n            slugMap.delete(slug);\n            const symbols = Array.from(entry.symbols.keys());\n            // @ts-ignore\n            thisQuote(symbols, queryOptionsOverrides, moduleOptions)\n                .then((results) => {\n                for (const result of results) {\n                    for (const promise of entry.symbols.get(result.symbol)) {\n                        promise.resolve(result);\n                        promise.resolved = true;\n                    }\n                }\n                // Check for symbols we asked for and didn't get back,\n                // e.g. non-existent symbols (#150)\n                for (const [_, promises] of entry.symbols) {\n                    for (const promise of promises) {\n                        if (!promise.resolved) {\n                            promise.resolve(undefined);\n                        }\n                    }\n                }\n            })\n                .catch((error) => {\n                for (const symbolPromiseCallbacks of entry.symbols.values())\n                    for (const promise of symbolPromiseCallbacks)\n                        promise.reject(error);\n            });\n        }, DEBOUNCE_TIME);\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}