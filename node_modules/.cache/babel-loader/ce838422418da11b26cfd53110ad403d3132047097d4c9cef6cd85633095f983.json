{"ast":null,"code":"import { Object } from '../object/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport { Union } from '../union/index.mjs';\nimport { IsTemplateLiteralFinite } from '../template-literal/index.mjs';\nimport { PatternStringExact, PatternNumberExact, PatternNeverExact } from '../patterns/index.mjs';\nimport { IndexPropertyKeys } from '../indexed/index.mjs';\nimport { Kind, Hint } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsUndefined } from '../guard/value.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsInteger, IsLiteral, IsAny, IsNever, IsNumber, IsString, IsRegExp, IsTemplateLiteral, IsUnion } from '../guard/kind.mjs';\n// ------------------------------------------------------------------\n// RecordCreateFromPattern\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction RecordCreateFromPattern(pattern, T, options) {\n  return {\n    ...options,\n    [Kind]: 'Record',\n    type: 'object',\n    patternProperties: {\n      [pattern]: CloneType(T)\n    }\n  };\n}\n// ------------------------------------------------------------------\n// RecordCreateFromKeys\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction RecordCreateFromKeys(K, T, options) {\n  const Acc = {};\n  for (const K2 of K) Acc[K2] = CloneType(T);\n  return Object(Acc, {\n    ...options,\n    [Hint]: 'Record'\n  });\n}\n// prettier-ignore\nfunction FromTemplateLiteralKey(K, T, options) {\n  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);\n}\n// prettier-ignore\nfunction FromUnionKey(K, T, options) {\n  return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);\n}\n// prettier-ignore\nfunction FromLiteralKey(K, T, options) {\n  return RecordCreateFromKeys([K.toString()], T, options);\n}\n// prettier-ignore\nfunction FromRegExpKey(K, T, options) {\n  return RecordCreateFromPattern(K.source, T, options);\n}\n// prettier-ignore\nfunction FromStringKey(K, T, options) {\n  const pattern = IsUndefined(K.pattern) ? PatternStringExact : K.pattern;\n  return RecordCreateFromPattern(pattern, T, options);\n}\n// prettier-ignore\nfunction FromAnyKey(K, T, options) {\n  return RecordCreateFromPattern(PatternStringExact, T, options);\n}\n// prettier-ignore\nfunction FromNeverKey(K, T, options) {\n  return RecordCreateFromPattern(PatternNeverExact, T, options);\n}\n// prettier-ignore\nfunction FromIntegerKey(_, T, options) {\n  return RecordCreateFromPattern(PatternNumberExact, T, options);\n}\n// prettier-ignore\nfunction FromNumberKey(_, T, options) {\n  return RecordCreateFromPattern(PatternNumberExact, T, options);\n}\n// ------------------------------------------------------------------\n// TRecordOrObject\n// ------------------------------------------------------------------\n/** `[Json]` Creates a Record type */\nexport function Record(K, T, options = {}) {\n  // prettier-ignore\n  return IsUnion(K) ? FromUnionKey(K.anyOf, T, options) : IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) : IsLiteral(K) ? FromLiteralKey(K.const, T, options) : IsInteger(K) ? FromIntegerKey(K, T, options) : IsNumber(K) ? FromNumberKey(K, T, options) : IsRegExp(K) ? FromRegExpKey(K, T, options) : IsString(K) ? FromStringKey(K, T, options) : IsAny(K) ? FromAnyKey(K, T, options) : IsNever(K) ? FromNeverKey(K, T, options) : Never(options);\n}","map":{"version":3,"names":["Object","Never","Union","IsTemplateLiteralFinite","PatternStringExact","PatternNumberExact","PatternNeverExact","IndexPropertyKeys","Kind","Hint","CloneType","IsUndefined","IsInteger","IsLiteral","IsAny","IsNever","IsNumber","IsString","IsRegExp","IsTemplateLiteral","IsUnion","RecordCreateFromPattern","pattern","T","options","type","patternProperties","RecordCreateFromKeys","K","Acc","K2","FromTemplateLiteralKey","FromUnionKey","FromLiteralKey","toString","FromRegExpKey","source","FromStringKey","FromAnyKey","FromNeverKey","FromIntegerKey","_","FromNumberKey","Record","anyOf","const"],"sources":["C:/Users/ordon/ThetaFlowz_Cursor/node_modules/yahoo-finance2/node_modules/@sinclair/typebox/build/esm/type/record/record.mjs"],"sourcesContent":["import { Object } from '../object/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport { Union } from '../union/index.mjs';\nimport { IsTemplateLiteralFinite } from '../template-literal/index.mjs';\nimport { PatternStringExact, PatternNumberExact, PatternNeverExact } from '../patterns/index.mjs';\nimport { IndexPropertyKeys } from '../indexed/index.mjs';\nimport { Kind, Hint } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsUndefined } from '../guard/value.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsInteger, IsLiteral, IsAny, IsNever, IsNumber, IsString, IsRegExp, IsTemplateLiteral, IsUnion } from '../guard/kind.mjs';\n// ------------------------------------------------------------------\n// RecordCreateFromPattern\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction RecordCreateFromPattern(pattern, T, options) {\n    return {\n        ...options,\n        [Kind]: 'Record',\n        type: 'object',\n        patternProperties: { [pattern]: CloneType(T) }\n    };\n}\n// ------------------------------------------------------------------\n// RecordCreateFromKeys\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction RecordCreateFromKeys(K, T, options) {\n    const Acc = {};\n    for (const K2 of K)\n        Acc[K2] = CloneType(T);\n    return Object(Acc, { ...options, [Hint]: 'Record' });\n}\n// prettier-ignore\nfunction FromTemplateLiteralKey(K, T, options) {\n    return (IsTemplateLiteralFinite(K)\n        ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options)\n        : RecordCreateFromPattern(K.pattern, T, options));\n}\n// prettier-ignore\nfunction FromUnionKey(K, T, options) {\n    return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);\n}\n// prettier-ignore\nfunction FromLiteralKey(K, T, options) {\n    return RecordCreateFromKeys([K.toString()], T, options);\n}\n// prettier-ignore\nfunction FromRegExpKey(K, T, options) {\n    return RecordCreateFromPattern(K.source, T, options);\n}\n// prettier-ignore\nfunction FromStringKey(K, T, options) {\n    const pattern = IsUndefined(K.pattern) ? PatternStringExact : K.pattern;\n    return RecordCreateFromPattern(pattern, T, options);\n}\n// prettier-ignore\nfunction FromAnyKey(K, T, options) {\n    return RecordCreateFromPattern(PatternStringExact, T, options);\n}\n// prettier-ignore\nfunction FromNeverKey(K, T, options) {\n    return RecordCreateFromPattern(PatternNeverExact, T, options);\n}\n// prettier-ignore\nfunction FromIntegerKey(_, T, options) {\n    return RecordCreateFromPattern(PatternNumberExact, T, options);\n}\n// prettier-ignore\nfunction FromNumberKey(_, T, options) {\n    return RecordCreateFromPattern(PatternNumberExact, T, options);\n}\n// ------------------------------------------------------------------\n// TRecordOrObject\n// ------------------------------------------------------------------\n/** `[Json]` Creates a Record type */\nexport function Record(K, T, options = {}) {\n    // prettier-ignore\n    return (IsUnion(K) ? FromUnionKey(K.anyOf, T, options) :\n        IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) :\n            IsLiteral(K) ? FromLiteralKey(K.const, T, options) :\n                IsInteger(K) ? FromIntegerKey(K, T, options) :\n                    IsNumber(K) ? FromNumberKey(K, T, options) :\n                        IsRegExp(K) ? FromRegExpKey(K, T, options) :\n                            IsString(K) ? FromStringKey(K, T, options) :\n                                IsAny(K) ? FromAnyKey(K, T, options) :\n                                    IsNever(K) ? FromNeverKey(K, T, options) :\n                                        Never(options));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}