{"ast":null,"code":"/*\n * moduleExec(options: ModuleExecOptions)\n *\n * 1. Query Stage\n *   1. Validate user-supplied module params, e.g. { period: '1d' }\n *   2. Merge query params: (module defaults, user-supplied overrides, etc)\n *   3. Optionally transform query params\n *\n * 2. Call lib/yahooFinanceFetch\n *\n * 3. Result Stage\n *   1. Optional transform the result\n *   2. Validate the result and coerce types\n *\n * Further info below, inline.\n */\nimport { validateAndCoerceTypebox } from \"./validateAndCoerceTypes.js\";\nimport csv2json from \"./csv2json.js\";\nasync function moduleExec(opts) {\n  var _a, _b;\n  const queryOpts = opts.query;\n  const moduleOpts = opts.moduleOptions;\n  const moduleName = opts.moduleName;\n  const resultOpts = opts.result;\n  if (queryOpts.assertSymbol) {\n    const symbol = queryOpts.assertSymbol;\n    if (typeof symbol !== \"string\") throw new Error(`yahooFinance.${moduleName}() expects a single string symbol as its ` + `query, not a(n) ${typeof symbol}: ${JSON.stringify(symbol)}`);\n  }\n  // Check that query options passed by the user are valid for this module\n  validateAndCoerceTypebox({\n    type: \"options\",\n    data: (_a = queryOpts.overrides) !== null && _a !== void 0 ? _a : {},\n    schema: queryOpts.schema,\n    options: this._opts.validation\n  });\n  let queryOptions = {\n    ...queryOpts.defaults,\n    // Module defaults e.g. { period: '1wk', lang: 'en' }\n    ...queryOpts.runtime,\n    // Runtime params e.g. { q: query }\n    ...queryOpts.overrides // User supplied options that override above\n  };\n  /*\n   * Called with the merged (defaults,runtime,overrides) before running\n   * the query.  Useful to transform options we allow but not Yahoo, e.g.\n   * allow a \"2020-01-01\" date but transform this to a UNIX epoch.\n   */\n  if (queryOpts.transformWith) {\n    queryOptions = queryOpts.transformWith(queryOptions);\n  }\n  // this._fetch is lib/yahooFinanceFetch\n  let result = await this._fetch(queryOpts.url, queryOptions, moduleOpts, queryOpts.fetchType, (_b = queryOpts.needsCrumb) !== null && _b !== void 0 ? _b : false);\n  if (queryOpts.fetchType === \"csv\") {\n    result = csv2json(result);\n  }\n  /*\n   * Mutate the Yahoo result *before* validating and coercion.  Mostly used\n   * to e.g. throw if no (result.returnField) and return result.returnField.\n   */\n  if (resultOpts.transformWith) {\n    result = resultOpts.transformWith(result);\n  }\n  const validateResult = !moduleOpts || moduleOpts.validateResult === undefined || moduleOpts.validateResult === true;\n  const validationOpts = {\n    ...this._opts.validation,\n    // Set logErrors=false if validateResult=false\n    logErrors: validateResult ? this._opts.validation.logErrors : false\n  };\n  /*\n   * Validate the returned result (after transforming, above) and coerce types.\n   *\n   * The coersion works as follows: if we're expecting a \"Date\" type, but Yahoo\n   * gives us { raw: 1231421524, fmt: \"2020-01-01\" }, we'll return that as\n   * `new Date(1231421524 * 1000)`.\n   *\n   * Beyond that, ensures that user won't process unexpected data, in two\n   * cases:\n   *\n   * a) Missing required properties or unexpected additional properties\n   * b) A total new change in format that we really have no idea what to do\n   *    with, e.g. a new kind of Date that we've never seen before and\n   *\n   * The idea is that if you receive a result, it's safe to use / store in\n   * database, etc.  Otherwise you'll receive an error.\n   */\n  try {\n    return validateAndCoerceTypebox({\n      type: \"result\",\n      data: result,\n      schema: resultOpts.schema,\n      options: validationOpts\n    });\n  } catch (error) {\n    if (validateResult) throw error;\n  }\n  return result;\n}\nexport default moduleExec;","map":{"version":3,"names":["validateAndCoerceTypebox","csv2json","moduleExec","opts","_a","_b","queryOpts","query","moduleOpts","moduleOptions","moduleName","resultOpts","result","assertSymbol","symbol","Error","JSON","stringify","type","data","overrides","schema","options","_opts","validation","queryOptions","defaults","runtime","transformWith","_fetch","url","fetchType","needsCrumb","validateResult","undefined","validationOpts","logErrors","error"],"sources":["C:/Users/ordon/ThetaFlowz_Cursor/node_modules/yahoo-finance2/dist/esm/src/lib/moduleExec.js"],"sourcesContent":["/*\n * moduleExec(options: ModuleExecOptions)\n *\n * 1. Query Stage\n *   1. Validate user-supplied module params, e.g. { period: '1d' }\n *   2. Merge query params: (module defaults, user-supplied overrides, etc)\n *   3. Optionally transform query params\n *\n * 2. Call lib/yahooFinanceFetch\n *\n * 3. Result Stage\n *   1. Optional transform the result\n *   2. Validate the result and coerce types\n *\n * Further info below, inline.\n */\nimport { validateAndCoerceTypebox } from \"./validateAndCoerceTypes.js\";\nimport csv2json from \"./csv2json.js\";\nasync function moduleExec(opts) {\n    var _a, _b;\n    const queryOpts = opts.query;\n    const moduleOpts = opts.moduleOptions;\n    const moduleName = opts.moduleName;\n    const resultOpts = opts.result;\n    if (queryOpts.assertSymbol) {\n        const symbol = queryOpts.assertSymbol;\n        if (typeof symbol !== \"string\")\n            throw new Error(`yahooFinance.${moduleName}() expects a single string symbol as its ` +\n                `query, not a(n) ${typeof symbol}: ${JSON.stringify(symbol)}`);\n    }\n    // Check that query options passed by the user are valid for this module\n    validateAndCoerceTypebox({\n        type: \"options\",\n        data: (_a = queryOpts.overrides) !== null && _a !== void 0 ? _a : {},\n        schema: queryOpts.schema,\n        options: this._opts.validation,\n    });\n    let queryOptions = {\n        ...queryOpts.defaults, // Module defaults e.g. { period: '1wk', lang: 'en' }\n        ...queryOpts.runtime, // Runtime params e.g. { q: query }\n        ...queryOpts.overrides, // User supplied options that override above\n    };\n    /*\n     * Called with the merged (defaults,runtime,overrides) before running\n     * the query.  Useful to transform options we allow but not Yahoo, e.g.\n     * allow a \"2020-01-01\" date but transform this to a UNIX epoch.\n     */\n    if (queryOpts.transformWith) {\n        queryOptions = queryOpts.transformWith(queryOptions);\n    }\n    // this._fetch is lib/yahooFinanceFetch\n    let result = await this._fetch(queryOpts.url, queryOptions, moduleOpts, queryOpts.fetchType, (_b = queryOpts.needsCrumb) !== null && _b !== void 0 ? _b : false);\n    if (queryOpts.fetchType === \"csv\") {\n        result = csv2json(result);\n    }\n    /*\n     * Mutate the Yahoo result *before* validating and coercion.  Mostly used\n     * to e.g. throw if no (result.returnField) and return result.returnField.\n     */\n    if (resultOpts.transformWith) {\n        result = resultOpts.transformWith(result);\n    }\n    const validateResult = !moduleOpts ||\n        moduleOpts.validateResult === undefined ||\n        moduleOpts.validateResult === true;\n    const validationOpts = {\n        ...this._opts.validation,\n        // Set logErrors=false if validateResult=false\n        logErrors: validateResult ? this._opts.validation.logErrors : false,\n    };\n    /*\n     * Validate the returned result (after transforming, above) and coerce types.\n     *\n     * The coersion works as follows: if we're expecting a \"Date\" type, but Yahoo\n     * gives us { raw: 1231421524, fmt: \"2020-01-01\" }, we'll return that as\n     * `new Date(1231421524 * 1000)`.\n     *\n     * Beyond that, ensures that user won't process unexpected data, in two\n     * cases:\n     *\n     * a) Missing required properties or unexpected additional properties\n     * b) A total new change in format that we really have no idea what to do\n     *    with, e.g. a new kind of Date that we've never seen before and\n     *\n     * The idea is that if you receive a result, it's safe to use / store in\n     * database, etc.  Otherwise you'll receive an error.\n     */\n    try {\n        return validateAndCoerceTypebox({\n            type: \"result\",\n            data: result,\n            schema: resultOpts.schema,\n            options: validationOpts,\n        });\n    }\n    catch (error) {\n        if (validateResult)\n            throw error;\n    }\n    return result;\n}\nexport default moduleExec;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,wBAAwB,QAAQ,6BAA6B;AACtE,OAAOC,QAAQ,MAAM,eAAe;AACpC,eAAeC,UAAUA,CAACC,IAAI,EAAE;EAC5B,IAAIC,EAAE,EAAEC,EAAE;EACV,MAAMC,SAAS,GAAGH,IAAI,CAACI,KAAK;EAC5B,MAAMC,UAAU,GAAGL,IAAI,CAACM,aAAa;EACrC,MAAMC,UAAU,GAAGP,IAAI,CAACO,UAAU;EAClC,MAAMC,UAAU,GAAGR,IAAI,CAACS,MAAM;EAC9B,IAAIN,SAAS,CAACO,YAAY,EAAE;IACxB,MAAMC,MAAM,GAAGR,SAAS,CAACO,YAAY;IACrC,IAAI,OAAOC,MAAM,KAAK,QAAQ,EAC1B,MAAM,IAAIC,KAAK,CAAC,gBAAgBL,UAAU,2CAA2C,GACjF,mBAAmB,OAAOI,MAAM,KAAKE,IAAI,CAACC,SAAS,CAACH,MAAM,CAAC,EAAE,CAAC;EAC1E;EACA;EACAd,wBAAwB,CAAC;IACrBkB,IAAI,EAAE,SAAS;IACfC,IAAI,EAAE,CAACf,EAAE,GAAGE,SAAS,CAACc,SAAS,MAAM,IAAI,IAAIhB,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,CAAC,CAAC;IACpEiB,MAAM,EAAEf,SAAS,CAACe,MAAM;IACxBC,OAAO,EAAE,IAAI,CAACC,KAAK,CAACC;EACxB,CAAC,CAAC;EACF,IAAIC,YAAY,GAAG;IACf,GAAGnB,SAAS,CAACoB,QAAQ;IAAE;IACvB,GAAGpB,SAAS,CAACqB,OAAO;IAAE;IACtB,GAAGrB,SAAS,CAACc,SAAS,CAAE;EAC5B,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI,IAAId,SAAS,CAACsB,aAAa,EAAE;IACzBH,YAAY,GAAGnB,SAAS,CAACsB,aAAa,CAACH,YAAY,CAAC;EACxD;EACA;EACA,IAAIb,MAAM,GAAG,MAAM,IAAI,CAACiB,MAAM,CAACvB,SAAS,CAACwB,GAAG,EAAEL,YAAY,EAAEjB,UAAU,EAAEF,SAAS,CAACyB,SAAS,EAAE,CAAC1B,EAAE,GAAGC,SAAS,CAAC0B,UAAU,MAAM,IAAI,IAAI3B,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,KAAK,CAAC;EAChK,IAAIC,SAAS,CAACyB,SAAS,KAAK,KAAK,EAAE;IAC/BnB,MAAM,GAAGX,QAAQ,CAACW,MAAM,CAAC;EAC7B;EACA;AACJ;AACA;AACA;EACI,IAAID,UAAU,CAACiB,aAAa,EAAE;IAC1BhB,MAAM,GAAGD,UAAU,CAACiB,aAAa,CAAChB,MAAM,CAAC;EAC7C;EACA,MAAMqB,cAAc,GAAG,CAACzB,UAAU,IAC9BA,UAAU,CAACyB,cAAc,KAAKC,SAAS,IACvC1B,UAAU,CAACyB,cAAc,KAAK,IAAI;EACtC,MAAME,cAAc,GAAG;IACnB,GAAG,IAAI,CAACZ,KAAK,CAACC,UAAU;IACxB;IACAY,SAAS,EAAEH,cAAc,GAAG,IAAI,CAACV,KAAK,CAACC,UAAU,CAACY,SAAS,GAAG;EAClE,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI;IACA,OAAOpC,wBAAwB,CAAC;MAC5BkB,IAAI,EAAE,QAAQ;MACdC,IAAI,EAAEP,MAAM;MACZS,MAAM,EAAEV,UAAU,CAACU,MAAM;MACzBC,OAAO,EAAEa;IACb,CAAC,CAAC;EACN,CAAC,CACD,OAAOE,KAAK,EAAE;IACV,IAAIJ,cAAc,EACd,MAAMI,KAAK;EACnB;EACA,OAAOzB,MAAM;AACjB;AACA,eAAeV,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}