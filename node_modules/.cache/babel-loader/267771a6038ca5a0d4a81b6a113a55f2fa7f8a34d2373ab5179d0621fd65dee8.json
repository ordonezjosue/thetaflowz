{"ast":null,"code":"import { IsTemplateLiteralExpressionFinite } from './finite.mjs';\nimport { TemplateLiteralParseExact } from './parse.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\n// ------------------------------------------------------------------\n// TemplateLiteralGenerateError\n// ------------------------------------------------------------------\nexport class TemplateLiteralGenerateError extends TypeBoxError {}\n// ------------------------------------------------------------------\n// TemplateLiteralExpressionGenerate\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction* GenerateReduce(buffer) {\n  if (buffer.length === 1) return yield* buffer[0];\n  for (const left of buffer[0]) {\n    for (const right of GenerateReduce(buffer.slice(1))) {\n      yield `${left}${right}`;\n    }\n  }\n}\n// prettier-ignore\nfunction* GenerateAnd(expression) {\n  return yield* GenerateReduce(expression.expr.map(expr => [...TemplateLiteralExpressionGenerate(expr)]));\n}\n// prettier-ignore\nfunction* GenerateOr(expression) {\n  for (const expr of expression.expr) yield* TemplateLiteralExpressionGenerate(expr);\n}\n// prettier-ignore\nfunction* GenerateConst(expression) {\n  return yield expression.const;\n}\nexport function* TemplateLiteralExpressionGenerate(expression) {\n  return expression.type === 'and' ? yield* GenerateAnd(expression) : expression.type === 'or' ? yield* GenerateOr(expression) : expression.type === 'const' ? yield* GenerateConst(expression) : (() => {\n    throw new TemplateLiteralGenerateError('Unknown expression');\n  })();\n}\n/** Generates a tuple of strings from the given TemplateLiteral. Returns an empty tuple if infinite. */\nexport function TemplateLiteralGenerate(schema) {\n  const expression = TemplateLiteralParseExact(schema.pattern);\n  // prettier-ignore\n  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];\n}","map":{"version":3,"names":["IsTemplateLiteralExpressionFinite","TemplateLiteralParseExact","TypeBoxError","TemplateLiteralGenerateError","GenerateReduce","buffer","length","left","right","slice","GenerateAnd","expression","expr","map","TemplateLiteralExpressionGenerate","GenerateOr","GenerateConst","const","type","TemplateLiteralGenerate","schema","pattern"],"sources":["C:/Users/ordon/ThetaFlowz_Cursor/node_modules/yahoo-finance2/node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs"],"sourcesContent":["import { IsTemplateLiteralExpressionFinite } from './finite.mjs';\nimport { TemplateLiteralParseExact } from './parse.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\n// ------------------------------------------------------------------\n// TemplateLiteralGenerateError\n// ------------------------------------------------------------------\nexport class TemplateLiteralGenerateError extends TypeBoxError {\n}\n// ------------------------------------------------------------------\n// TemplateLiteralExpressionGenerate\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction* GenerateReduce(buffer) {\n    if (buffer.length === 1)\n        return yield* buffer[0];\n    for (const left of buffer[0]) {\n        for (const right of GenerateReduce(buffer.slice(1))) {\n            yield `${left}${right}`;\n        }\n    }\n}\n// prettier-ignore\nfunction* GenerateAnd(expression) {\n    return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));\n}\n// prettier-ignore\nfunction* GenerateOr(expression) {\n    for (const expr of expression.expr)\n        yield* TemplateLiteralExpressionGenerate(expr);\n}\n// prettier-ignore\nfunction* GenerateConst(expression) {\n    return yield expression.const;\n}\nexport function* TemplateLiteralExpressionGenerate(expression) {\n    return expression.type === 'and'\n        ? yield* GenerateAnd(expression)\n        : expression.type === 'or'\n            ? yield* GenerateOr(expression)\n            : expression.type === 'const'\n                ? yield* GenerateConst(expression)\n                : (() => {\n                    throw new TemplateLiteralGenerateError('Unknown expression');\n                })();\n}\n/** Generates a tuple of strings from the given TemplateLiteral. Returns an empty tuple if infinite. */\nexport function TemplateLiteralGenerate(schema) {\n    const expression = TemplateLiteralParseExact(schema.pattern);\n    // prettier-ignore\n    return (IsTemplateLiteralExpressionFinite(expression)\n        ? [...TemplateLiteralExpressionGenerate(expression)]\n        : []);\n}\n"],"mappings":"AAAA,SAASA,iCAAiC,QAAQ,cAAc;AAChE,SAASC,yBAAyB,QAAQ,aAAa;AACvD,SAASC,YAAY,QAAQ,oBAAoB;AACjD;AACA;AACA;AACA,OAAO,MAAMC,4BAA4B,SAASD,YAAY,CAAC;AAE/D;AACA;AACA;AACA;AACA,UAAUE,cAAcA,CAACC,MAAM,EAAE;EAC7B,IAAIA,MAAM,CAACC,MAAM,KAAK,CAAC,EACnB,OAAO,OAAOD,MAAM,CAAC,CAAC,CAAC;EAC3B,KAAK,MAAME,IAAI,IAAIF,MAAM,CAAC,CAAC,CAAC,EAAE;IAC1B,KAAK,MAAMG,KAAK,IAAIJ,cAAc,CAACC,MAAM,CAACI,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;MACjD,MAAM,GAAGF,IAAI,GAAGC,KAAK,EAAE;IAC3B;EACJ;AACJ;AACA;AACA,UAAUE,WAAWA,CAACC,UAAU,EAAE;EAC9B,OAAO,OAAOP,cAAc,CAACO,UAAU,CAACC,IAAI,CAACC,GAAG,CAAED,IAAI,IAAK,CAAC,GAAGE,iCAAiC,CAACF,IAAI,CAAC,CAAC,CAAC,CAAC;AAC7G;AACA;AACA,UAAUG,UAAUA,CAACJ,UAAU,EAAE;EAC7B,KAAK,MAAMC,IAAI,IAAID,UAAU,CAACC,IAAI,EAC9B,OAAOE,iCAAiC,CAACF,IAAI,CAAC;AACtD;AACA;AACA,UAAUI,aAAaA,CAACL,UAAU,EAAE;EAChC,OAAO,MAAMA,UAAU,CAACM,KAAK;AACjC;AACA,OAAO,UAAUH,iCAAiCA,CAACH,UAAU,EAAE;EAC3D,OAAOA,UAAU,CAACO,IAAI,KAAK,KAAK,GAC1B,OAAOR,WAAW,CAACC,UAAU,CAAC,GAC9BA,UAAU,CAACO,IAAI,KAAK,IAAI,GACpB,OAAOH,UAAU,CAACJ,UAAU,CAAC,GAC7BA,UAAU,CAACO,IAAI,KAAK,OAAO,GACvB,OAAOF,aAAa,CAACL,UAAU,CAAC,GAChC,CAAC,MAAM;IACL,MAAM,IAAIR,4BAA4B,CAAC,oBAAoB,CAAC;EAChE,CAAC,EAAE,CAAC;AACpB;AACA;AACA,OAAO,SAASgB,uBAAuBA,CAACC,MAAM,EAAE;EAC5C,MAAMT,UAAU,GAAGV,yBAAyB,CAACmB,MAAM,CAACC,OAAO,CAAC;EAC5D;EACA,OAAQrB,iCAAiC,CAACW,UAAU,CAAC,GAC/C,CAAC,GAAGG,iCAAiC,CAACH,UAAU,CAAC,CAAC,GAClD,EAAE;AACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}