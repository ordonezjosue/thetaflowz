{"ast":null,"code":"import { KeyOfPropertyKeys } from '../../type/keyof/index.mjs';\nimport { Check } from '../check/index.mjs';\nimport { Clone } from '../clone/index.mjs';\nimport { Deref } from '../deref/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { IsString, IsObject, IsArray, IsUndefined } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { IsSchema } from '../../type/guard/type.mjs';\n// ------------------------------------------------------------------\n// IsCheckable\n// ------------------------------------------------------------------\nfunction IsCheckable(schema) {\n  return IsSchema(schema) && schema[Kind] !== 'Unsafe';\n}\n// ------------------------------------------------------------------\n// Types\n// ------------------------------------------------------------------\nfunction FromArray(schema, references, value) {\n  if (!IsArray(value)) return value;\n  return value.map(value => Visit(schema.items, references, value));\n}\nfunction FromIntersect(schema, references, value) {\n  const unevaluatedProperties = schema.unevaluatedProperties;\n  const intersections = schema.allOf.map(schema => Visit(schema, references, Clone(value)));\n  const composite = intersections.reduce((acc, value) => IsObject(value) ? {\n    ...acc,\n    ...value\n  } : value, {});\n  if (!IsObject(value) || !IsObject(composite) || !IsSchema(unevaluatedProperties)) return composite;\n  const knownkeys = KeyOfPropertyKeys(schema);\n  for (const key of Object.getOwnPropertyNames(value)) {\n    if (knownkeys.includes(key)) continue;\n    if (Check(unevaluatedProperties, references, value[key])) {\n      composite[key] = Visit(unevaluatedProperties, references, value[key]);\n    }\n  }\n  return composite;\n}\nfunction FromObject(schema, references, value) {\n  if (!IsObject(value) || IsArray(value)) return value; // Check IsArray for AllowArrayObject configuration\n  const additionalProperties = schema.additionalProperties;\n  for (const key of Object.getOwnPropertyNames(value)) {\n    if (key in schema.properties) {\n      value[key] = Visit(schema.properties[key], references, value[key]);\n      continue;\n    }\n    if (IsSchema(additionalProperties) && Check(additionalProperties, references, value[key])) {\n      value[key] = Visit(additionalProperties, references, value[key]);\n      continue;\n    }\n    delete value[key];\n  }\n  return value;\n}\nfunction FromRecord(schema, references, value) {\n  if (!IsObject(value)) return value;\n  const additionalProperties = schema.additionalProperties;\n  const propertyKeys = Object.getOwnPropertyNames(value);\n  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];\n  const propertyKeyTest = new RegExp(propertyKey);\n  for (const key of propertyKeys) {\n    if (propertyKeyTest.test(key)) {\n      value[key] = Visit(propertySchema, references, value[key]);\n      continue;\n    }\n    if (IsSchema(additionalProperties) && Check(additionalProperties, references, value[key])) {\n      value[key] = Visit(additionalProperties, references, value[key]);\n      continue;\n    }\n    delete value[key];\n  }\n  return value;\n}\nfunction FromRef(schema, references, value) {\n  return Visit(Deref(schema, references), references, value);\n}\nfunction FromThis(schema, references, value) {\n  return Visit(Deref(schema, references), references, value);\n}\nfunction FromTuple(schema, references, value) {\n  if (!IsArray(value)) return value;\n  if (IsUndefined(schema.items)) return [];\n  const length = Math.min(value.length, schema.items.length);\n  for (let i = 0; i < length; i++) {\n    value[i] = Visit(schema.items[i], references, value[i]);\n  }\n  // prettier-ignore\n  return value.length > length ? value.slice(0, length) : value;\n}\nfunction FromUnion(schema, references, value) {\n  for (const inner of schema.anyOf) {\n    if (IsCheckable(inner) && Check(inner, references, value)) {\n      return Visit(inner, references, value);\n    }\n  }\n  return value;\n}\nfunction Visit(schema, references, value) {\n  const references_ = IsString(schema.$id) ? [...references, schema] : references;\n  const schema_ = schema;\n  switch (schema_[Kind]) {\n    case 'Array':\n      return FromArray(schema_, references_, value);\n    case 'Intersect':\n      return FromIntersect(schema_, references_, value);\n    case 'Object':\n      return FromObject(schema_, references_, value);\n    case 'Record':\n      return FromRecord(schema_, references_, value);\n    case 'Ref':\n      return FromRef(schema_, references_, value);\n    case 'This':\n      return FromThis(schema_, references_, value);\n    case 'Tuple':\n      return FromTuple(schema_, references_, value);\n    case 'Union':\n      return FromUnion(schema_, references_, value);\n    default:\n      return value;\n  }\n}\n/** `[Mutable]` Removes excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first. */\nexport function Clean(...args) {\n  return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}","map":{"version":3,"names":["KeyOfPropertyKeys","Check","Clone","Deref","Kind","IsString","IsObject","IsArray","IsUndefined","IsSchema","IsCheckable","schema","FromArray","references","value","map","Visit","items","FromIntersect","unevaluatedProperties","intersections","allOf","composite","reduce","acc","knownkeys","key","Object","getOwnPropertyNames","includes","FromObject","additionalProperties","properties","FromRecord","propertyKeys","propertyKey","propertySchema","entries","patternProperties","propertyKeyTest","RegExp","test","FromRef","FromThis","FromTuple","length","Math","min","i","slice","FromUnion","inner","anyOf","references_","$id","schema_","Clean","args"],"sources":["C:/Users/ordon/ThetaFlowz_Cursor/node_modules/yahoo-finance2/node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs"],"sourcesContent":["import { KeyOfPropertyKeys } from '../../type/keyof/index.mjs';\nimport { Check } from '../check/index.mjs';\nimport { Clone } from '../clone/index.mjs';\nimport { Deref } from '../deref/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { IsString, IsObject, IsArray, IsUndefined } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { IsSchema } from '../../type/guard/type.mjs';\n// ------------------------------------------------------------------\n// IsCheckable\n// ------------------------------------------------------------------\nfunction IsCheckable(schema) {\n    return IsSchema(schema) && schema[Kind] !== 'Unsafe';\n}\n// ------------------------------------------------------------------\n// Types\n// ------------------------------------------------------------------\nfunction FromArray(schema, references, value) {\n    if (!IsArray(value))\n        return value;\n    return value.map((value) => Visit(schema.items, references, value));\n}\nfunction FromIntersect(schema, references, value) {\n    const unevaluatedProperties = schema.unevaluatedProperties;\n    const intersections = schema.allOf.map((schema) => Visit(schema, references, Clone(value)));\n    const composite = intersections.reduce((acc, value) => (IsObject(value) ? { ...acc, ...value } : value), {});\n    if (!IsObject(value) || !IsObject(composite) || !IsSchema(unevaluatedProperties))\n        return composite;\n    const knownkeys = KeyOfPropertyKeys(schema);\n    for (const key of Object.getOwnPropertyNames(value)) {\n        if (knownkeys.includes(key))\n            continue;\n        if (Check(unevaluatedProperties, references, value[key])) {\n            composite[key] = Visit(unevaluatedProperties, references, value[key]);\n        }\n    }\n    return composite;\n}\nfunction FromObject(schema, references, value) {\n    if (!IsObject(value) || IsArray(value))\n        return value; // Check IsArray for AllowArrayObject configuration\n    const additionalProperties = schema.additionalProperties;\n    for (const key of Object.getOwnPropertyNames(value)) {\n        if (key in schema.properties) {\n            value[key] = Visit(schema.properties[key], references, value[key]);\n            continue;\n        }\n        if (IsSchema(additionalProperties) && Check(additionalProperties, references, value[key])) {\n            value[key] = Visit(additionalProperties, references, value[key]);\n            continue;\n        }\n        delete value[key];\n    }\n    return value;\n}\nfunction FromRecord(schema, references, value) {\n    if (!IsObject(value))\n        return value;\n    const additionalProperties = schema.additionalProperties;\n    const propertyKeys = Object.getOwnPropertyNames(value);\n    const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];\n    const propertyKeyTest = new RegExp(propertyKey);\n    for (const key of propertyKeys) {\n        if (propertyKeyTest.test(key)) {\n            value[key] = Visit(propertySchema, references, value[key]);\n            continue;\n        }\n        if (IsSchema(additionalProperties) && Check(additionalProperties, references, value[key])) {\n            value[key] = Visit(additionalProperties, references, value[key]);\n            continue;\n        }\n        delete value[key];\n    }\n    return value;\n}\nfunction FromRef(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromThis(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromTuple(schema, references, value) {\n    if (!IsArray(value))\n        return value;\n    if (IsUndefined(schema.items))\n        return [];\n    const length = Math.min(value.length, schema.items.length);\n    for (let i = 0; i < length; i++) {\n        value[i] = Visit(schema.items[i], references, value[i]);\n    }\n    // prettier-ignore\n    return value.length > length\n        ? value.slice(0, length)\n        : value;\n}\nfunction FromUnion(schema, references, value) {\n    for (const inner of schema.anyOf) {\n        if (IsCheckable(inner) && Check(inner, references, value)) {\n            return Visit(inner, references, value);\n        }\n    }\n    return value;\n}\nfunction Visit(schema, references, value) {\n    const references_ = IsString(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[Kind]) {\n        case 'Array':\n            return FromArray(schema_, references_, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, value);\n        case 'Object':\n            return FromObject(schema_, references_, value);\n        case 'Record':\n            return FromRecord(schema_, references_, value);\n        case 'Ref':\n            return FromRef(schema_, references_, value);\n        case 'This':\n            return FromThis(schema_, references_, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, value);\n        case 'Union':\n            return FromUnion(schema_, references_, value);\n        default:\n            return value;\n    }\n}\n/** `[Mutable]` Removes excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first. */\nexport function Clean(...args) {\n    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}