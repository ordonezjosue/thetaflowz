{"ast":null,"code":"import { TypeSystemPolicy } from '../system/index.mjs';\nimport { KeyOfPattern } from '../type/keyof/index.mjs';\nimport { TypeRegistry, FormatRegistry } from '../type/registry/index.mjs';\nimport { ExtendsUndefinedCheck } from '../type/extends/extends-undefined.mjs';\nimport { GetErrorFunction } from './function.mjs';\nimport { TypeBoxError } from '../type/error/index.mjs';\nimport { Deref } from '../value/deref/index.mjs';\nimport { Hash } from '../value/hash/index.mjs';\nimport { Kind } from '../type/symbols/index.mjs';\nimport { Never } from '../type/never/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { IsArray, IsUint8Array, IsDate, IsPromise, IsFunction, IsAsyncIterator, IsIterator, IsBoolean, IsNumber, IsBigInt, IsString, IsSymbol, IsInteger, IsNull, IsUndefined } from '../value/guard/index.mjs';\n// ------------------------------------------------------------------\n// ValueErrorType\n// ------------------------------------------------------------------\nexport var ValueErrorType;\n(function (ValueErrorType) {\n  ValueErrorType[ValueErrorType[\"ArrayContains\"] = 0] = \"ArrayContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMaxContains\"] = 1] = \"ArrayMaxContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMaxItems\"] = 2] = \"ArrayMaxItems\";\n  ValueErrorType[ValueErrorType[\"ArrayMinContains\"] = 3] = \"ArrayMinContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMinItems\"] = 4] = \"ArrayMinItems\";\n  ValueErrorType[ValueErrorType[\"ArrayUniqueItems\"] = 5] = \"ArrayUniqueItems\";\n  ValueErrorType[ValueErrorType[\"Array\"] = 6] = \"Array\";\n  ValueErrorType[ValueErrorType[\"AsyncIterator\"] = 7] = \"AsyncIterator\";\n  ValueErrorType[ValueErrorType[\"BigIntExclusiveMaximum\"] = 8] = \"BigIntExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"BigIntExclusiveMinimum\"] = 9] = \"BigIntExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"BigIntMaximum\"] = 10] = \"BigIntMaximum\";\n  ValueErrorType[ValueErrorType[\"BigIntMinimum\"] = 11] = \"BigIntMinimum\";\n  ValueErrorType[ValueErrorType[\"BigIntMultipleOf\"] = 12] = \"BigIntMultipleOf\";\n  ValueErrorType[ValueErrorType[\"BigInt\"] = 13] = \"BigInt\";\n  ValueErrorType[ValueErrorType[\"Boolean\"] = 14] = \"Boolean\";\n  ValueErrorType[ValueErrorType[\"DateExclusiveMaximumTimestamp\"] = 15] = \"DateExclusiveMaximumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateExclusiveMinimumTimestamp\"] = 16] = \"DateExclusiveMinimumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMaximumTimestamp\"] = 17] = \"DateMaximumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMinimumTimestamp\"] = 18] = \"DateMinimumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMultipleOfTimestamp\"] = 19] = \"DateMultipleOfTimestamp\";\n  ValueErrorType[ValueErrorType[\"Date\"] = 20] = \"Date\";\n  ValueErrorType[ValueErrorType[\"Function\"] = 21] = \"Function\";\n  ValueErrorType[ValueErrorType[\"IntegerExclusiveMaximum\"] = 22] = \"IntegerExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"IntegerExclusiveMinimum\"] = 23] = \"IntegerExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"IntegerMaximum\"] = 24] = \"IntegerMaximum\";\n  ValueErrorType[ValueErrorType[\"IntegerMinimum\"] = 25] = \"IntegerMinimum\";\n  ValueErrorType[ValueErrorType[\"IntegerMultipleOf\"] = 26] = \"IntegerMultipleOf\";\n  ValueErrorType[ValueErrorType[\"Integer\"] = 27] = \"Integer\";\n  ValueErrorType[ValueErrorType[\"IntersectUnevaluatedProperties\"] = 28] = \"IntersectUnevaluatedProperties\";\n  ValueErrorType[ValueErrorType[\"Intersect\"] = 29] = \"Intersect\";\n  ValueErrorType[ValueErrorType[\"Iterator\"] = 30] = \"Iterator\";\n  ValueErrorType[ValueErrorType[\"Kind\"] = 31] = \"Kind\";\n  ValueErrorType[ValueErrorType[\"Literal\"] = 32] = \"Literal\";\n  ValueErrorType[ValueErrorType[\"Never\"] = 33] = \"Never\";\n  ValueErrorType[ValueErrorType[\"Not\"] = 34] = \"Not\";\n  ValueErrorType[ValueErrorType[\"Null\"] = 35] = \"Null\";\n  ValueErrorType[ValueErrorType[\"NumberExclusiveMaximum\"] = 36] = \"NumberExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"NumberExclusiveMinimum\"] = 37] = \"NumberExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"NumberMaximum\"] = 38] = \"NumberMaximum\";\n  ValueErrorType[ValueErrorType[\"NumberMinimum\"] = 39] = \"NumberMinimum\";\n  ValueErrorType[ValueErrorType[\"NumberMultipleOf\"] = 40] = \"NumberMultipleOf\";\n  ValueErrorType[ValueErrorType[\"Number\"] = 41] = \"Number\";\n  ValueErrorType[ValueErrorType[\"ObjectAdditionalProperties\"] = 42] = \"ObjectAdditionalProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectMaxProperties\"] = 43] = \"ObjectMaxProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectMinProperties\"] = 44] = \"ObjectMinProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectRequiredProperty\"] = 45] = \"ObjectRequiredProperty\";\n  ValueErrorType[ValueErrorType[\"Object\"] = 46] = \"Object\";\n  ValueErrorType[ValueErrorType[\"Promise\"] = 47] = \"Promise\";\n  ValueErrorType[ValueErrorType[\"RegExp\"] = 48] = \"RegExp\";\n  ValueErrorType[ValueErrorType[\"StringFormatUnknown\"] = 49] = \"StringFormatUnknown\";\n  ValueErrorType[ValueErrorType[\"StringFormat\"] = 50] = \"StringFormat\";\n  ValueErrorType[ValueErrorType[\"StringMaxLength\"] = 51] = \"StringMaxLength\";\n  ValueErrorType[ValueErrorType[\"StringMinLength\"] = 52] = \"StringMinLength\";\n  ValueErrorType[ValueErrorType[\"StringPattern\"] = 53] = \"StringPattern\";\n  ValueErrorType[ValueErrorType[\"String\"] = 54] = \"String\";\n  ValueErrorType[ValueErrorType[\"Symbol\"] = 55] = \"Symbol\";\n  ValueErrorType[ValueErrorType[\"TupleLength\"] = 56] = \"TupleLength\";\n  ValueErrorType[ValueErrorType[\"Tuple\"] = 57] = \"Tuple\";\n  ValueErrorType[ValueErrorType[\"Uint8ArrayMaxByteLength\"] = 58] = \"Uint8ArrayMaxByteLength\";\n  ValueErrorType[ValueErrorType[\"Uint8ArrayMinByteLength\"] = 59] = \"Uint8ArrayMinByteLength\";\n  ValueErrorType[ValueErrorType[\"Uint8Array\"] = 60] = \"Uint8Array\";\n  ValueErrorType[ValueErrorType[\"Undefined\"] = 61] = \"Undefined\";\n  ValueErrorType[ValueErrorType[\"Union\"] = 62] = \"Union\";\n  ValueErrorType[ValueErrorType[\"Void\"] = 63] = \"Void\";\n})(ValueErrorType || (ValueErrorType = {}));\n// ------------------------------------------------------------------\n// ValueErrors\n// ------------------------------------------------------------------\nexport class ValueErrorsUnknownTypeError extends TypeBoxError {\n  constructor(schema) {\n    super('Unknown type');\n    this.schema = schema;\n  }\n}\n// ------------------------------------------------------------------\n// EscapeKey\n// ------------------------------------------------------------------\nfunction EscapeKey(key) {\n  return key.replace(/~/g, '~0').replace(/\\//g, '~1'); // RFC6901 Path\n}\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nfunction IsDefined(value) {\n  return value !== undefined;\n}\n// ------------------------------------------------------------------\n// ValueErrorIterator\n// ------------------------------------------------------------------\nexport class ValueErrorIterator {\n  constructor(iterator) {\n    this.iterator = iterator;\n  }\n  [Symbol.iterator]() {\n    return this.iterator;\n  }\n  /** Returns the first value error or undefined if no errors */\n  First() {\n    const next = this.iterator.next();\n    return next.done ? undefined : next.value;\n  }\n}\n// --------------------------------------------------------------------------\n// Create\n// --------------------------------------------------------------------------\nfunction Create(errorType, schema, path, value) {\n  return {\n    type: errorType,\n    schema,\n    path,\n    value,\n    message: GetErrorFunction()({\n      errorType,\n      path,\n      schema,\n      value\n    })\n  };\n}\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction* FromAny(schema, references, path, value) {}\nfunction* FromArray(schema, references, path, value) {\n  if (!IsArray(value)) {\n    return yield Create(ValueErrorType.Array, schema, path, value);\n  }\n  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);\n  }\n  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);\n  }\n  for (let i = 0; i < value.length; i++) {\n    yield* Visit(schema.items, references, `${path}/${i}`, value[i]);\n  }\n  // prettier-ignore\n  if (schema.uniqueItems === true && !function () {\n    const set = new Set();\n    for (const element of value) {\n      const hashed = Hash(element);\n      if (set.has(hashed)) {\n        return false;\n      } else {\n        set.add(hashed);\n      }\n    }\n    return true;\n  }()) {\n    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);\n  }\n  // contains\n  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {\n    return;\n  }\n  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();\n  const containsCount = value.reduce((acc, value, index) => Visit(containsSchema, references, `${path}${index}`, value).next().done === true ? acc + 1 : acc, 0);\n  if (containsCount === 0) {\n    yield Create(ValueErrorType.ArrayContains, schema, path, value);\n  }\n  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {\n    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);\n  }\n  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {\n    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);\n  }\n}\nfunction* FromAsyncIterator(schema, references, path, value) {\n  if (!IsAsyncIterator(value)) yield Create(ValueErrorType.AsyncIterator, schema, path, value);\n}\nfunction* FromBigInt(schema, references, path, value) {\n  if (!IsBigInt(value)) return yield Create(ValueErrorType.BigInt, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);\n  }\n}\nfunction* FromBoolean(schema, references, path, value) {\n  if (!IsBoolean(value)) yield Create(ValueErrorType.Boolean, schema, path, value);\n}\nfunction* FromConstructor(schema, references, path, value) {\n  yield* Visit(schema.returns, references, path, value.prototype);\n}\nfunction* FromDate(schema, references, path, value) {\n  if (!IsDate(value)) return yield Create(ValueErrorType.Date, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);\n  }\n}\nfunction* FromFunction(schema, references, path, value) {\n  if (!IsFunction(value)) yield Create(ValueErrorType.Function, schema, path, value);\n}\nfunction* FromInteger(schema, references, path, value) {\n  if (!IsInteger(value)) return yield Create(ValueErrorType.Integer, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);\n  }\n}\nfunction* FromIntersect(schema, references, path, value) {\n  for (const inner of schema.allOf) {\n    const next = Visit(inner, references, path, value).next();\n    if (!next.done) {\n      yield Create(ValueErrorType.Intersect, schema, path, value);\n      yield next.value;\n    }\n  }\n  if (schema.unevaluatedProperties === false) {\n    const keyCheck = new RegExp(KeyOfPattern(schema));\n    for (const valueKey of Object.getOwnPropertyNames(value)) {\n      if (!keyCheck.test(valueKey)) {\n        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);\n      }\n    }\n  }\n  if (typeof schema.unevaluatedProperties === 'object') {\n    const keyCheck = new RegExp(KeyOfPattern(schema));\n    for (const valueKey of Object.getOwnPropertyNames(value)) {\n      if (!keyCheck.test(valueKey)) {\n        const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();\n        if (!next.done) yield next.value; // yield interior\n      }\n    }\n  }\n}\nfunction* FromIterator(schema, references, path, value) {\n  if (!IsIterator(value)) yield Create(ValueErrorType.Iterator, schema, path, value);\n}\nfunction* FromLiteral(schema, references, path, value) {\n  if (!(value === schema.const)) yield Create(ValueErrorType.Literal, schema, path, value);\n}\nfunction* FromNever(schema, references, path, value) {\n  yield Create(ValueErrorType.Never, schema, path, value);\n}\nfunction* FromNot(schema, references, path, value) {\n  if (Visit(schema.not, references, path, value).next().done === true) yield Create(ValueErrorType.Not, schema, path, value);\n}\nfunction* FromNull(schema, references, path, value) {\n  if (!IsNull(value)) yield Create(ValueErrorType.Null, schema, path, value);\n}\nfunction* FromNumber(schema, references, path, value) {\n  if (!TypeSystemPolicy.IsNumberLike(value)) return yield Create(ValueErrorType.Number, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.NumberMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.NumberMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);\n  }\n}\nfunction* FromObject(schema, references, path, value) {\n  if (!TypeSystemPolicy.IsObjectLike(value)) return yield Create(ValueErrorType.Object, schema, path, value);\n  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n  }\n  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n  }\n  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];\n  const knownKeys = Object.getOwnPropertyNames(schema.properties);\n  const unknownKeys = Object.getOwnPropertyNames(value);\n  for (const requiredKey of requiredKeys) {\n    if (unknownKeys.includes(requiredKey)) continue;\n    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);\n  }\n  if (schema.additionalProperties === false) {\n    for (const valueKey of unknownKeys) {\n      if (!knownKeys.includes(valueKey)) {\n        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n      }\n    }\n  }\n  if (typeof schema.additionalProperties === 'object') {\n    for (const valueKey of unknownKeys) {\n      if (knownKeys.includes(valueKey)) continue;\n      yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n    }\n  }\n  for (const knownKey of knownKeys) {\n    const property = schema.properties[knownKey];\n    if (schema.required && schema.required.includes(knownKey)) {\n      yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n      if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {\n        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);\n      }\n    } else {\n      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {\n        yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n      }\n    }\n  }\n}\nfunction* FromPromise(schema, references, path, value) {\n  if (!IsPromise(value)) yield Create(ValueErrorType.Promise, schema, path, value);\n}\nfunction* FromRecord(schema, references, path, value) {\n  if (!TypeSystemPolicy.IsRecordLike(value)) return yield Create(ValueErrorType.Object, schema, path, value);\n  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n  }\n  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n  }\n  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n  const regex = new RegExp(patternKey);\n  for (const [propertyKey, propertyValue] of Object.entries(value)) {\n    if (regex.test(propertyKey)) yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n  }\n  if (typeof schema.additionalProperties === 'object') {\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n      if (!regex.test(propertyKey)) yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n  }\n  if (schema.additionalProperties === false) {\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n      if (regex.test(propertyKey)) continue;\n      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n  }\n}\nfunction* FromRef(schema, references, path, value) {\n  yield* Visit(Deref(schema, references), references, path, value);\n}\nfunction* FromRegExp(schema, references, path, value) {\n  if (!IsString(value)) return yield Create(ValueErrorType.String, schema, path, value);\n  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n    yield Create(ValueErrorType.StringMinLength, schema, path, value);\n  }\n  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n    yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n  }\n  const regex = new RegExp(schema.source, schema.flags);\n  if (!regex.test(value)) {\n    return yield Create(ValueErrorType.RegExp, schema, path, value);\n  }\n}\nfunction* FromString(schema, references, path, value) {\n  if (!IsString(value)) return yield Create(ValueErrorType.String, schema, path, value);\n  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n    yield Create(ValueErrorType.StringMinLength, schema, path, value);\n  }\n  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n    yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n  }\n  if (IsString(schema.pattern)) {\n    const regex = new RegExp(schema.pattern);\n    if (!regex.test(value)) {\n      yield Create(ValueErrorType.StringPattern, schema, path, value);\n    }\n  }\n  if (IsString(schema.format)) {\n    if (!FormatRegistry.Has(schema.format)) {\n      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);\n    } else {\n      const format = FormatRegistry.Get(schema.format);\n      if (!format(value)) {\n        yield Create(ValueErrorType.StringFormat, schema, path, value);\n      }\n    }\n  }\n}\nfunction* FromSymbol(schema, references, path, value) {\n  if (!IsSymbol(value)) yield Create(ValueErrorType.Symbol, schema, path, value);\n}\nfunction* FromTemplateLiteral(schema, references, path, value) {\n  if (!IsString(value)) return yield Create(ValueErrorType.String, schema, path, value);\n  const regex = new RegExp(schema.pattern);\n  if (!regex.test(value)) {\n    yield Create(ValueErrorType.StringPattern, schema, path, value);\n  }\n}\nfunction* FromThis(schema, references, path, value) {\n  yield* Visit(Deref(schema, references), references, path, value);\n}\nfunction* FromTuple(schema, references, path, value) {\n  if (!IsArray(value)) return yield Create(ValueErrorType.Tuple, schema, path, value);\n  if (schema.items === undefined && !(value.length === 0)) {\n    return yield Create(ValueErrorType.TupleLength, schema, path, value);\n  }\n  if (!(value.length === schema.maxItems)) {\n    return yield Create(ValueErrorType.TupleLength, schema, path, value);\n  }\n  if (!schema.items) {\n    return;\n  }\n  for (let i = 0; i < schema.items.length; i++) {\n    yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);\n  }\n}\nfunction* FromUndefined(schema, references, path, value) {\n  if (!IsUndefined(value)) yield Create(ValueErrorType.Undefined, schema, path, value);\n}\nfunction* FromUnion(schema, references, path, value) {\n  let count = 0;\n  for (const subschema of schema.anyOf) {\n    const errors = [...Visit(subschema, references, path, value)];\n    if (errors.length === 0) return; // matched\n    count += errors.length;\n  }\n  if (count > 0) {\n    yield Create(ValueErrorType.Union, schema, path, value);\n  }\n}\nfunction* FromUint8Array(schema, references, path, value) {\n  if (!IsUint8Array(value)) return yield Create(ValueErrorType.Uint8Array, schema, path, value);\n  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);\n  }\n  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);\n  }\n}\nfunction* FromUnknown(schema, references, path, value) {}\nfunction* FromVoid(schema, references, path, value) {\n  if (!TypeSystemPolicy.IsVoidLike(value)) yield Create(ValueErrorType.Void, schema, path, value);\n}\nfunction* FromKind(schema, references, path, value) {\n  const check = TypeRegistry.Get(schema[Kind]);\n  if (!check(schema, value)) yield Create(ValueErrorType.Kind, schema, path, value);\n}\nfunction* Visit(schema, references, path, value) {\n  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n  const schema_ = schema;\n  switch (schema_[Kind]) {\n    case 'Any':\n      return yield* FromAny(schema_, references_, path, value);\n    case 'Array':\n      return yield* FromArray(schema_, references_, path, value);\n    case 'AsyncIterator':\n      return yield* FromAsyncIterator(schema_, references_, path, value);\n    case 'BigInt':\n      return yield* FromBigInt(schema_, references_, path, value);\n    case 'Boolean':\n      return yield* FromBoolean(schema_, references_, path, value);\n    case 'Constructor':\n      return yield* FromConstructor(schema_, references_, path, value);\n    case 'Date':\n      return yield* FromDate(schema_, references_, path, value);\n    case 'Function':\n      return yield* FromFunction(schema_, references_, path, value);\n    case 'Integer':\n      return yield* FromInteger(schema_, references_, path, value);\n    case 'Intersect':\n      return yield* FromIntersect(schema_, references_, path, value);\n    case 'Iterator':\n      return yield* FromIterator(schema_, references_, path, value);\n    case 'Literal':\n      return yield* FromLiteral(schema_, references_, path, value);\n    case 'Never':\n      return yield* FromNever(schema_, references_, path, value);\n    case 'Not':\n      return yield* FromNot(schema_, references_, path, value);\n    case 'Null':\n      return yield* FromNull(schema_, references_, path, value);\n    case 'Number':\n      return yield* FromNumber(schema_, references_, path, value);\n    case 'Object':\n      return yield* FromObject(schema_, references_, path, value);\n    case 'Promise':\n      return yield* FromPromise(schema_, references_, path, value);\n    case 'Record':\n      return yield* FromRecord(schema_, references_, path, value);\n    case 'Ref':\n      return yield* FromRef(schema_, references_, path, value);\n    case 'RegExp':\n      return yield* FromRegExp(schema_, references_, path, value);\n    case 'String':\n      return yield* FromString(schema_, references_, path, value);\n    case 'Symbol':\n      return yield* FromSymbol(schema_, references_, path, value);\n    case 'TemplateLiteral':\n      return yield* FromTemplateLiteral(schema_, references_, path, value);\n    case 'This':\n      return yield* FromThis(schema_, references_, path, value);\n    case 'Tuple':\n      return yield* FromTuple(schema_, references_, path, value);\n    case 'Undefined':\n      return yield* FromUndefined(schema_, references_, path, value);\n    case 'Union':\n      return yield* FromUnion(schema_, references_, path, value);\n    case 'Uint8Array':\n      return yield* FromUint8Array(schema_, references_, path, value);\n    case 'Unknown':\n      return yield* FromUnknown(schema_, references_, path, value);\n    case 'Void':\n      return yield* FromVoid(schema_, references_, path, value);\n    default:\n      if (!TypeRegistry.Has(schema_[Kind])) throw new ValueErrorsUnknownTypeError(schema);\n      return yield* FromKind(schema_, references_, path, value);\n  }\n}\n/** Returns an iterator for each error in this value. */\nexport function Errors(...args) {\n  const iterator = args.length === 3 ? Visit(args[0], args[1], '', args[2]) : Visit(args[0], [], '', args[1]);\n  return new ValueErrorIterator(iterator);\n}","map":{"version":3,"names":["TypeSystemPolicy","KeyOfPattern","TypeRegistry","FormatRegistry","ExtendsUndefinedCheck","GetErrorFunction","TypeBoxError","Deref","Hash","Kind","Never","IsArray","IsUint8Array","IsDate","IsPromise","IsFunction","IsAsyncIterator","IsIterator","IsBoolean","IsNumber","IsBigInt","IsString","IsSymbol","IsInteger","IsNull","IsUndefined","ValueErrorType","ValueErrorsUnknownTypeError","constructor","schema","EscapeKey","key","replace","IsDefined","value","undefined","ValueErrorIterator","iterator","Symbol","First","next","done","Create","errorType","path","type","message","FromAny","references","FromArray","Array","minItems","length","ArrayMinItems","maxItems","ArrayMaxItems","i","Visit","items","uniqueItems","set","Set","element","hashed","has","add","ArrayUniqueItems","contains","minContains","maxContains","containsSchema","containsCount","reduce","acc","index","ArrayContains","ArrayMinContains","ArrayMaxContains","FromAsyncIterator","AsyncIterator","FromBigInt","BigInt","exclusiveMaximum","BigIntExclusiveMaximum","exclusiveMinimum","BigIntExclusiveMinimum","maximum","BigIntMaximum","minimum","BigIntMinimum","multipleOf","BigIntMultipleOf","FromBoolean","Boolean","FromConstructor","returns","prototype","FromDate","Date","exclusiveMaximumTimestamp","getTime","DateExclusiveMaximumTimestamp","exclusiveMinimumTimestamp","DateExclusiveMinimumTimestamp","maximumTimestamp","DateMaximumTimestamp","minimumTimestamp","DateMinimumTimestamp","multipleOfTimestamp","DateMultipleOfTimestamp","FromFunction","Function","FromInteger","Integer","IntegerExclusiveMaximum","IntegerExclusiveMinimum","IntegerMaximum","IntegerMinimum","IntegerMultipleOf","FromIntersect","inner","allOf","Intersect","unevaluatedProperties","keyCheck","RegExp","valueKey","Object","getOwnPropertyNames","test","IntersectUnevaluatedProperties","FromIterator","Iterator","FromLiteral","const","Literal","FromNever","FromNot","not","Not","FromNull","Null","FromNumber","IsNumberLike","Number","NumberExclusiveMaximum","NumberExclusiveMinimum","NumberMaximum","NumberMinimum","NumberMultipleOf","FromObject","IsObjectLike","minProperties","ObjectMinProperties","maxProperties","ObjectMaxProperties","requiredKeys","isArray","required","knownKeys","properties","unknownKeys","requiredKey","includes","ObjectRequiredProperty","additionalProperties","ObjectAdditionalProperties","knownKey","property","IsExactOptionalProperty","FromPromise","Promise","FromRecord","IsRecordLike","patternKey","patternSchema","entries","patternProperties","regex","propertyKey","propertyValue","FromRef","FromRegExp","String","minLength","StringMinLength","maxLength","StringMaxLength","source","flags","FromString","pattern","StringPattern","format","Has","StringFormatUnknown","Get","StringFormat","FromSymbol","FromTemplateLiteral","FromThis","FromTuple","Tuple","TupleLength","FromUndefined","Undefined","FromUnion","count","subschema","anyOf","errors","Union","FromUint8Array","Uint8Array","maxByteLength","Uint8ArrayMaxByteLength","minByteLength","Uint8ArrayMinByteLength","FromUnknown","FromVoid","IsVoidLike","Void","FromKind","check","references_","$id","schema_","Errors","args"],"sources":["C:/Users/ordon/ThetaFlowz_Cursor/node_modules/yahoo-finance2/node_modules/@sinclair/typebox/build/esm/errors/errors.mjs"],"sourcesContent":["import { TypeSystemPolicy } from '../system/index.mjs';\nimport { KeyOfPattern } from '../type/keyof/index.mjs';\nimport { TypeRegistry, FormatRegistry } from '../type/registry/index.mjs';\nimport { ExtendsUndefinedCheck } from '../type/extends/extends-undefined.mjs';\nimport { GetErrorFunction } from './function.mjs';\nimport { TypeBoxError } from '../type/error/index.mjs';\nimport { Deref } from '../value/deref/index.mjs';\nimport { Hash } from '../value/hash/index.mjs';\nimport { Kind } from '../type/symbols/index.mjs';\nimport { Never } from '../type/never/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { IsArray, IsUint8Array, IsDate, IsPromise, IsFunction, IsAsyncIterator, IsIterator, IsBoolean, IsNumber, IsBigInt, IsString, IsSymbol, IsInteger, IsNull, IsUndefined } from '../value/guard/index.mjs';\n// ------------------------------------------------------------------\n// ValueErrorType\n// ------------------------------------------------------------------\nexport var ValueErrorType;\n(function (ValueErrorType) {\n    ValueErrorType[ValueErrorType[\"ArrayContains\"] = 0] = \"ArrayContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxContains\"] = 1] = \"ArrayMaxContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxItems\"] = 2] = \"ArrayMaxItems\";\n    ValueErrorType[ValueErrorType[\"ArrayMinContains\"] = 3] = \"ArrayMinContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMinItems\"] = 4] = \"ArrayMinItems\";\n    ValueErrorType[ValueErrorType[\"ArrayUniqueItems\"] = 5] = \"ArrayUniqueItems\";\n    ValueErrorType[ValueErrorType[\"Array\"] = 6] = \"Array\";\n    ValueErrorType[ValueErrorType[\"AsyncIterator\"] = 7] = \"AsyncIterator\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMaximum\"] = 8] = \"BigIntExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMinimum\"] = 9] = \"BigIntExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMaximum\"] = 10] = \"BigIntMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntMinimum\"] = 11] = \"BigIntMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMultipleOf\"] = 12] = \"BigIntMultipleOf\";\n    ValueErrorType[ValueErrorType[\"BigInt\"] = 13] = \"BigInt\";\n    ValueErrorType[ValueErrorType[\"Boolean\"] = 14] = \"Boolean\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMaximumTimestamp\"] = 15] = \"DateExclusiveMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMinimumTimestamp\"] = 16] = \"DateExclusiveMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMaximumTimestamp\"] = 17] = \"DateMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMinimumTimestamp\"] = 18] = \"DateMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMultipleOfTimestamp\"] = 19] = \"DateMultipleOfTimestamp\";\n    ValueErrorType[ValueErrorType[\"Date\"] = 20] = \"Date\";\n    ValueErrorType[ValueErrorType[\"Function\"] = 21] = \"Function\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMaximum\"] = 22] = \"IntegerExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMinimum\"] = 23] = \"IntegerExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMaximum\"] = 24] = \"IntegerMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerMinimum\"] = 25] = \"IntegerMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMultipleOf\"] = 26] = \"IntegerMultipleOf\";\n    ValueErrorType[ValueErrorType[\"Integer\"] = 27] = \"Integer\";\n    ValueErrorType[ValueErrorType[\"IntersectUnevaluatedProperties\"] = 28] = \"IntersectUnevaluatedProperties\";\n    ValueErrorType[ValueErrorType[\"Intersect\"] = 29] = \"Intersect\";\n    ValueErrorType[ValueErrorType[\"Iterator\"] = 30] = \"Iterator\";\n    ValueErrorType[ValueErrorType[\"Kind\"] = 31] = \"Kind\";\n    ValueErrorType[ValueErrorType[\"Literal\"] = 32] = \"Literal\";\n    ValueErrorType[ValueErrorType[\"Never\"] = 33] = \"Never\";\n    ValueErrorType[ValueErrorType[\"Not\"] = 34] = \"Not\";\n    ValueErrorType[ValueErrorType[\"Null\"] = 35] = \"Null\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMaximum\"] = 36] = \"NumberExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMinimum\"] = 37] = \"NumberExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMaximum\"] = 38] = \"NumberMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberMinimum\"] = 39] = \"NumberMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMultipleOf\"] = 40] = \"NumberMultipleOf\";\n    ValueErrorType[ValueErrorType[\"Number\"] = 41] = \"Number\";\n    ValueErrorType[ValueErrorType[\"ObjectAdditionalProperties\"] = 42] = \"ObjectAdditionalProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMaxProperties\"] = 43] = \"ObjectMaxProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMinProperties\"] = 44] = \"ObjectMinProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectRequiredProperty\"] = 45] = \"ObjectRequiredProperty\";\n    ValueErrorType[ValueErrorType[\"Object\"] = 46] = \"Object\";\n    ValueErrorType[ValueErrorType[\"Promise\"] = 47] = \"Promise\";\n    ValueErrorType[ValueErrorType[\"RegExp\"] = 48] = \"RegExp\";\n    ValueErrorType[ValueErrorType[\"StringFormatUnknown\"] = 49] = \"StringFormatUnknown\";\n    ValueErrorType[ValueErrorType[\"StringFormat\"] = 50] = \"StringFormat\";\n    ValueErrorType[ValueErrorType[\"StringMaxLength\"] = 51] = \"StringMaxLength\";\n    ValueErrorType[ValueErrorType[\"StringMinLength\"] = 52] = \"StringMinLength\";\n    ValueErrorType[ValueErrorType[\"StringPattern\"] = 53] = \"StringPattern\";\n    ValueErrorType[ValueErrorType[\"String\"] = 54] = \"String\";\n    ValueErrorType[ValueErrorType[\"Symbol\"] = 55] = \"Symbol\";\n    ValueErrorType[ValueErrorType[\"TupleLength\"] = 56] = \"TupleLength\";\n    ValueErrorType[ValueErrorType[\"Tuple\"] = 57] = \"Tuple\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMaxByteLength\"] = 58] = \"Uint8ArrayMaxByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMinByteLength\"] = 59] = \"Uint8ArrayMinByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8Array\"] = 60] = \"Uint8Array\";\n    ValueErrorType[ValueErrorType[\"Undefined\"] = 61] = \"Undefined\";\n    ValueErrorType[ValueErrorType[\"Union\"] = 62] = \"Union\";\n    ValueErrorType[ValueErrorType[\"Void\"] = 63] = \"Void\";\n})(ValueErrorType || (ValueErrorType = {}));\n// ------------------------------------------------------------------\n// ValueErrors\n// ------------------------------------------------------------------\nexport class ValueErrorsUnknownTypeError extends TypeBoxError {\n    constructor(schema) {\n        super('Unknown type');\n        this.schema = schema;\n    }\n}\n// ------------------------------------------------------------------\n// EscapeKey\n// ------------------------------------------------------------------\nfunction EscapeKey(key) {\n    return key.replace(/~/g, '~0').replace(/\\//g, '~1'); // RFC6901 Path\n}\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nfunction IsDefined(value) {\n    return value !== undefined;\n}\n// ------------------------------------------------------------------\n// ValueErrorIterator\n// ------------------------------------------------------------------\nexport class ValueErrorIterator {\n    constructor(iterator) {\n        this.iterator = iterator;\n    }\n    [Symbol.iterator]() {\n        return this.iterator;\n    }\n    /** Returns the first value error or undefined if no errors */\n    First() {\n        const next = this.iterator.next();\n        return next.done ? undefined : next.value;\n    }\n}\n// --------------------------------------------------------------------------\n// Create\n// --------------------------------------------------------------------------\nfunction Create(errorType, schema, path, value) {\n    return { type: errorType, schema, path, value, message: GetErrorFunction()({ errorType, path, schema, value }) };\n}\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction* FromAny(schema, references, path, value) { }\nfunction* FromArray(schema, references, path, value) {\n    if (!IsArray(value)) {\n        return yield Create(ValueErrorType.Array, schema, path, value);\n    }\n    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n        yield Create(ValueErrorType.ArrayMinItems, schema, path, value);\n    }\n    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n        yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);\n    }\n    for (let i = 0; i < value.length; i++) {\n        yield* Visit(schema.items, references, `${path}/${i}`, value[i]);\n    }\n    // prettier-ignore\n    if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {\n        const hashed = Hash(element);\n        if (set.has(hashed)) {\n            return false;\n        }\n        else {\n            set.add(hashed);\n        }\n    } return true; })())) {\n        yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);\n    }\n    // contains\n    if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {\n        return;\n    }\n    const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();\n    const containsCount = value.reduce((acc, value, index) => (Visit(containsSchema, references, `${path}${index}`, value).next().done === true ? acc + 1 : acc), 0);\n    if (containsCount === 0) {\n        yield Create(ValueErrorType.ArrayContains, schema, path, value);\n    }\n    if (IsNumber(schema.minContains) && containsCount < schema.minContains) {\n        yield Create(ValueErrorType.ArrayMinContains, schema, path, value);\n    }\n    if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {\n        yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);\n    }\n}\nfunction* FromAsyncIterator(schema, references, path, value) {\n    if (!IsAsyncIterator(value))\n        yield Create(ValueErrorType.AsyncIterator, schema, path, value);\n}\nfunction* FromBigInt(schema, references, path, value) {\n    if (!IsBigInt(value))\n        return yield Create(ValueErrorType.BigInt, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.BigIntMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.BigIntMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n        yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);\n    }\n}\nfunction* FromBoolean(schema, references, path, value) {\n    if (!IsBoolean(value))\n        yield Create(ValueErrorType.Boolean, schema, path, value);\n}\nfunction* FromConstructor(schema, references, path, value) {\n    yield* Visit(schema.returns, references, path, value.prototype);\n}\nfunction* FromDate(schema, references, path, value) {\n    if (!IsDate(value))\n        return yield Create(ValueErrorType.Date, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n        yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n        yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n        yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n        yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n        yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);\n    }\n}\nfunction* FromFunction(schema, references, path, value) {\n    if (!IsFunction(value))\n        yield Create(ValueErrorType.Function, schema, path, value);\n}\nfunction* FromInteger(schema, references, path, value) {\n    if (!IsInteger(value))\n        return yield Create(ValueErrorType.Integer, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.IntegerMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.IntegerMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);\n    }\n}\nfunction* FromIntersect(schema, references, path, value) {\n    for (const inner of schema.allOf) {\n        const next = Visit(inner, references, path, value).next();\n        if (!next.done) {\n            yield Create(ValueErrorType.Intersect, schema, path, value);\n            yield next.value;\n        }\n    }\n    if (schema.unevaluatedProperties === false) {\n        const keyCheck = new RegExp(KeyOfPattern(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);\n            }\n        }\n    }\n    if (typeof schema.unevaluatedProperties === 'object') {\n        const keyCheck = new RegExp(KeyOfPattern(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();\n                if (!next.done)\n                    yield next.value; // yield interior\n            }\n        }\n    }\n}\nfunction* FromIterator(schema, references, path, value) {\n    if (!IsIterator(value))\n        yield Create(ValueErrorType.Iterator, schema, path, value);\n}\nfunction* FromLiteral(schema, references, path, value) {\n    if (!(value === schema.const))\n        yield Create(ValueErrorType.Literal, schema, path, value);\n}\nfunction* FromNever(schema, references, path, value) {\n    yield Create(ValueErrorType.Never, schema, path, value);\n}\nfunction* FromNot(schema, references, path, value) {\n    if (Visit(schema.not, references, path, value).next().done === true)\n        yield Create(ValueErrorType.Not, schema, path, value);\n}\nfunction* FromNull(schema, references, path, value) {\n    if (!IsNull(value))\n        yield Create(ValueErrorType.Null, schema, path, value);\n}\nfunction* FromNumber(schema, references, path, value) {\n    if (!TypeSystemPolicy.IsNumberLike(value))\n        return yield Create(ValueErrorType.Number, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.NumberMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.NumberMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);\n    }\n}\nfunction* FromObject(schema, references, path, value) {\n    if (!TypeSystemPolicy.IsObjectLike(value))\n        return yield Create(ValueErrorType.Object, schema, path, value);\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n    }\n    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];\n    const knownKeys = Object.getOwnPropertyNames(schema.properties);\n    const unknownKeys = Object.getOwnPropertyNames(value);\n    for (const requiredKey of requiredKeys) {\n        if (unknownKeys.includes(requiredKey))\n            continue;\n        yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);\n    }\n    if (schema.additionalProperties === false) {\n        for (const valueKey of unknownKeys) {\n            if (!knownKeys.includes(valueKey)) {\n                yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n            }\n        }\n    }\n    if (typeof schema.additionalProperties === 'object') {\n        for (const valueKey of unknownKeys) {\n            if (knownKeys.includes(valueKey))\n                continue;\n            yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n        }\n    }\n    for (const knownKey of knownKeys) {\n        const property = schema.properties[knownKey];\n        if (schema.required && schema.required.includes(knownKey)) {\n            yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n            if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {\n                yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);\n            }\n        }\n        else {\n            if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {\n                yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n            }\n        }\n    }\n}\nfunction* FromPromise(schema, references, path, value) {\n    if (!IsPromise(value))\n        yield Create(ValueErrorType.Promise, schema, path, value);\n}\nfunction* FromRecord(schema, references, path, value) {\n    if (!TypeSystemPolicy.IsRecordLike(value))\n        return yield Create(ValueErrorType.Object, schema, path, value);\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n    }\n    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n    const regex = new RegExp(patternKey);\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n        if (regex.test(propertyKey))\n            yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n    if (typeof schema.additionalProperties === 'object') {\n        for (const [propertyKey, propertyValue] of Object.entries(value)) {\n            if (!regex.test(propertyKey))\n                yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n        }\n    }\n    if (schema.additionalProperties === false) {\n        for (const [propertyKey, propertyValue] of Object.entries(value)) {\n            if (regex.test(propertyKey))\n                continue;\n            return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n        }\n    }\n}\nfunction* FromRef(schema, references, path, value) {\n    yield* Visit(Deref(schema, references), references, path, value);\n}\nfunction* FromRegExp(schema, references, path, value) {\n    if (!IsString(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n        yield Create(ValueErrorType.StringMinLength, schema, path, value);\n    }\n    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n        yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n    }\n    const regex = new RegExp(schema.source, schema.flags);\n    if (!regex.test(value)) {\n        return yield Create(ValueErrorType.RegExp, schema, path, value);\n    }\n}\nfunction* FromString(schema, references, path, value) {\n    if (!IsString(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n        yield Create(ValueErrorType.StringMinLength, schema, path, value);\n    }\n    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n        yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n    }\n    if (IsString(schema.pattern)) {\n        const regex = new RegExp(schema.pattern);\n        if (!regex.test(value)) {\n            yield Create(ValueErrorType.StringPattern, schema, path, value);\n        }\n    }\n    if (IsString(schema.format)) {\n        if (!FormatRegistry.Has(schema.format)) {\n            yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);\n        }\n        else {\n            const format = FormatRegistry.Get(schema.format);\n            if (!format(value)) {\n                yield Create(ValueErrorType.StringFormat, schema, path, value);\n            }\n        }\n    }\n}\nfunction* FromSymbol(schema, references, path, value) {\n    if (!IsSymbol(value))\n        yield Create(ValueErrorType.Symbol, schema, path, value);\n}\nfunction* FromTemplateLiteral(schema, references, path, value) {\n    if (!IsString(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    const regex = new RegExp(schema.pattern);\n    if (!regex.test(value)) {\n        yield Create(ValueErrorType.StringPattern, schema, path, value);\n    }\n}\nfunction* FromThis(schema, references, path, value) {\n    yield* Visit(Deref(schema, references), references, path, value);\n}\nfunction* FromTuple(schema, references, path, value) {\n    if (!IsArray(value))\n        return yield Create(ValueErrorType.Tuple, schema, path, value);\n    if (schema.items === undefined && !(value.length === 0)) {\n        return yield Create(ValueErrorType.TupleLength, schema, path, value);\n    }\n    if (!(value.length === schema.maxItems)) {\n        return yield Create(ValueErrorType.TupleLength, schema, path, value);\n    }\n    if (!schema.items) {\n        return;\n    }\n    for (let i = 0; i < schema.items.length; i++) {\n        yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);\n    }\n}\nfunction* FromUndefined(schema, references, path, value) {\n    if (!IsUndefined(value))\n        yield Create(ValueErrorType.Undefined, schema, path, value);\n}\nfunction* FromUnion(schema, references, path, value) {\n    let count = 0;\n    for (const subschema of schema.anyOf) {\n        const errors = [...Visit(subschema, references, path, value)];\n        if (errors.length === 0)\n            return; // matched\n        count += errors.length;\n    }\n    if (count > 0) {\n        yield Create(ValueErrorType.Union, schema, path, value);\n    }\n}\nfunction* FromUint8Array(schema, references, path, value) {\n    if (!IsUint8Array(value))\n        return yield Create(ValueErrorType.Uint8Array, schema, path, value);\n    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n        yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);\n    }\n    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n        yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);\n    }\n}\nfunction* FromUnknown(schema, references, path, value) { }\nfunction* FromVoid(schema, references, path, value) {\n    if (!TypeSystemPolicy.IsVoidLike(value))\n        yield Create(ValueErrorType.Void, schema, path, value);\n}\nfunction* FromKind(schema, references, path, value) {\n    const check = TypeRegistry.Get(schema[Kind]);\n    if (!check(schema, value))\n        yield Create(ValueErrorType.Kind, schema, path, value);\n}\nfunction* Visit(schema, references, path, value) {\n    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[Kind]) {\n        case 'Any':\n            return yield* FromAny(schema_, references_, path, value);\n        case 'Array':\n            return yield* FromArray(schema_, references_, path, value);\n        case 'AsyncIterator':\n            return yield* FromAsyncIterator(schema_, references_, path, value);\n        case 'BigInt':\n            return yield* FromBigInt(schema_, references_, path, value);\n        case 'Boolean':\n            return yield* FromBoolean(schema_, references_, path, value);\n        case 'Constructor':\n            return yield* FromConstructor(schema_, references_, path, value);\n        case 'Date':\n            return yield* FromDate(schema_, references_, path, value);\n        case 'Function':\n            return yield* FromFunction(schema_, references_, path, value);\n        case 'Integer':\n            return yield* FromInteger(schema_, references_, path, value);\n        case 'Intersect':\n            return yield* FromIntersect(schema_, references_, path, value);\n        case 'Iterator':\n            return yield* FromIterator(schema_, references_, path, value);\n        case 'Literal':\n            return yield* FromLiteral(schema_, references_, path, value);\n        case 'Never':\n            return yield* FromNever(schema_, references_, path, value);\n        case 'Not':\n            return yield* FromNot(schema_, references_, path, value);\n        case 'Null':\n            return yield* FromNull(schema_, references_, path, value);\n        case 'Number':\n            return yield* FromNumber(schema_, references_, path, value);\n        case 'Object':\n            return yield* FromObject(schema_, references_, path, value);\n        case 'Promise':\n            return yield* FromPromise(schema_, references_, path, value);\n        case 'Record':\n            return yield* FromRecord(schema_, references_, path, value);\n        case 'Ref':\n            return yield* FromRef(schema_, references_, path, value);\n        case 'RegExp':\n            return yield* FromRegExp(schema_, references_, path, value);\n        case 'String':\n            return yield* FromString(schema_, references_, path, value);\n        case 'Symbol':\n            return yield* FromSymbol(schema_, references_, path, value);\n        case 'TemplateLiteral':\n            return yield* FromTemplateLiteral(schema_, references_, path, value);\n        case 'This':\n            return yield* FromThis(schema_, references_, path, value);\n        case 'Tuple':\n            return yield* FromTuple(schema_, references_, path, value);\n        case 'Undefined':\n            return yield* FromUndefined(schema_, references_, path, value);\n        case 'Union':\n            return yield* FromUnion(schema_, references_, path, value);\n        case 'Uint8Array':\n            return yield* FromUint8Array(schema_, references_, path, value);\n        case 'Unknown':\n            return yield* FromUnknown(schema_, references_, path, value);\n        case 'Void':\n            return yield* FromVoid(schema_, references_, path, value);\n        default:\n            if (!TypeRegistry.Has(schema_[Kind]))\n                throw new ValueErrorsUnknownTypeError(schema);\n            return yield* FromKind(schema_, references_, path, value);\n    }\n}\n/** Returns an iterator for each error in this value. */\nexport function Errors(...args) {\n    const iterator = args.length === 3 ? Visit(args[0], args[1], '', args[2]) : Visit(args[0], [], '', args[1]);\n    return new ValueErrorIterator(iterator);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}