{"ast":null,"code":"import { Any } from '../any/index.mjs';\nimport { Function as FunctionType } from '../function/index.mjs';\nimport { Number } from '../number/index.mjs';\nimport { String } from '../string/index.mjs';\nimport { Unknown } from '../unknown/index.mjs';\nimport { TemplateLiteralToUnion } from '../template-literal/index.mjs';\nimport { PatternNumberExact, PatternStringExact } from '../patterns/index.mjs';\nimport { Kind, Hint } from '../symbols/index.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\nimport { TypeGuard, ValueGuard } from '../guard/index.mjs';\nexport class ExtendsResolverError extends TypeBoxError {}\nexport var ExtendsResult;\n(function (ExtendsResult) {\n  ExtendsResult[ExtendsResult[\"Union\"] = 0] = \"Union\";\n  ExtendsResult[ExtendsResult[\"True\"] = 1] = \"True\";\n  ExtendsResult[ExtendsResult[\"False\"] = 2] = \"False\";\n})(ExtendsResult || (ExtendsResult = {}));\n// ------------------------------------------------------------------\n// IntoBooleanResult\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IntoBooleanResult(result) {\n  return result === ExtendsResult.False ? result : ExtendsResult.True;\n}\n// ------------------------------------------------------------------\n// Throw\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction Throw(message) {\n  throw new ExtendsResolverError(message);\n}\n// ------------------------------------------------------------------\n// StructuralRight\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsStructuralRight(right) {\n  return TypeGuard.IsNever(right) || TypeGuard.IsIntersect(right) || TypeGuard.IsUnion(right) || TypeGuard.IsUnknown(right) || TypeGuard.IsAny(right);\n}\n// prettier-ignore\nfunction StructuralRight(left, right) {\n  return TypeGuard.IsNever(right) ? FromNeverRight(left, right) : TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) : TypeGuard.IsAny(right) ? FromAnyRight(left, right) : Throw('StructuralRight');\n}\n// ------------------------------------------------------------------\n// Any\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromAnyRight(left, right) {\n  return ExtendsResult.True;\n}\n// prettier-ignore\nfunction FromAny(left, right) {\n  return TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : TypeGuard.IsUnion(right) && right.anyOf.some(schema => TypeGuard.IsAny(schema) || TypeGuard.IsUnknown(schema)) ? ExtendsResult.True : TypeGuard.IsUnion(right) ? ExtendsResult.Union : TypeGuard.IsUnknown(right) ? ExtendsResult.True : TypeGuard.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;\n}\n// ------------------------------------------------------------------\n// Array\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromArrayRight(left, right) {\n  return TypeGuard.IsUnknown(left) ? ExtendsResult.False : TypeGuard.IsAny(left) ? ExtendsResult.Union : TypeGuard.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromArray(left, right) {\n  return TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));\n}\n// ------------------------------------------------------------------\n// AsyncIterator\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromAsyncIterator(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));\n}\n// ------------------------------------------------------------------\n// BigInt\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromBigInt(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.IsObject(right) ? FromObjectRight(left, right) : TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : TypeGuard.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Boolean\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromBooleanRight(left, right) {\n  return TypeGuard.IsLiteralBoolean(left) ? ExtendsResult.True : TypeGuard.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromBoolean(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.IsObject(right) ? FromObjectRight(left, right) : TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : TypeGuard.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Constructor\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromConstructor(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !TypeGuard.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));\n}\n// ------------------------------------------------------------------\n// Date\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromDate(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.IsObject(right) ? FromObjectRight(left, right) : TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : TypeGuard.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Function\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromFunction(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !TypeGuard.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));\n}\n// ------------------------------------------------------------------\n// Integer\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromIntegerRight(left, right) {\n  return TypeGuard.IsLiteral(left) && ValueGuard.IsNumber(left.const) ? ExtendsResult.True : TypeGuard.IsNumber(left) || TypeGuard.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromInteger(left, right) {\n  return TypeGuard.IsInteger(right) || TypeGuard.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.IsObject(right) ? FromObjectRight(left, right) : TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Intersect\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromIntersectRight(left, right) {\n  return right.allOf.every(schema => Visit(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromIntersect(left, right) {\n  return left.allOf.some(schema => Visit(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Iterator\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromIterator(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));\n}\n// ------------------------------------------------------------------\n// Literal\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromLiteral(left, right) {\n  return TypeGuard.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.IsObject(right) ? FromObjectRight(left, right) : TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : TypeGuard.IsString(right) ? FromStringRight(left, right) : TypeGuard.IsNumber(right) ? FromNumberRight(left, right) : TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) : TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Never\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromNeverRight(left, right) {\n  return ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromNever(left, right) {\n  return ExtendsResult.True;\n}\n// ------------------------------------------------------------------\n// Not\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction UnwrapTNot(schema) {\n  let [current, depth] = [schema, 0];\n  while (true) {\n    if (!TypeGuard.IsNot(current)) break;\n    current = current.not;\n    depth += 1;\n  }\n  return depth % 2 === 0 ? current : Unknown();\n}\n// prettier-ignore\nfunction FromNot(left, right) {\n  // TypeScript has no concept of negated types, and attempts to correctly check the negated\n  // type at runtime would put TypeBox at odds with TypeScripts ability to statically infer\n  // the type. Instead we unwrap to either unknown or T and continue evaluating.\n  // prettier-ignore\n  return TypeGuard.IsNot(left) ? Visit(UnwrapTNot(left), right) : TypeGuard.IsNot(right) ? Visit(left, UnwrapTNot(right)) : Throw('Invalid fallthrough for Not');\n}\n// ------------------------------------------------------------------\n// Null\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromNull(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.IsObject(right) ? FromObjectRight(left, right) : TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : TypeGuard.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Number\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromNumberRight(left, right) {\n  return TypeGuard.IsLiteralNumber(left) ? ExtendsResult.True : TypeGuard.IsNumber(left) || TypeGuard.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromNumber(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.IsObject(right) ? FromObjectRight(left, right) : TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : TypeGuard.IsInteger(right) || TypeGuard.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Object\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsObjectPropertyCount(schema, count) {\n  return Object.getOwnPropertyNames(schema.properties).length === count;\n}\n// prettier-ignore\nfunction IsObjectStringLike(schema) {\n  return IsObjectArrayLike(schema);\n}\n// prettier-ignore\nfunction IsObjectSymbolLike(schema) {\n  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && TypeGuard.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.IsString(schema.properties.description.anyOf[0]) && TypeGuard.IsUndefined(schema.properties.description.anyOf[1]) || TypeGuard.IsString(schema.properties.description.anyOf[1]) && TypeGuard.IsUndefined(schema.properties.description.anyOf[0]));\n}\n// prettier-ignore\nfunction IsObjectNumberLike(schema) {\n  return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectBooleanLike(schema) {\n  return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectBigIntLike(schema) {\n  return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectDateLike(schema) {\n  return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectUint8ArrayLike(schema) {\n  return IsObjectArrayLike(schema);\n}\n// prettier-ignore\nfunction IsObjectFunctionLike(schema) {\n  const length = Number();\n  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === ExtendsResult.True;\n}\n// prettier-ignore\nfunction IsObjectConstructorLike(schema) {\n  return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectArrayLike(schema) {\n  const length = Number();\n  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === ExtendsResult.True;\n}\n// prettier-ignore\nfunction IsObjectPromiseLike(schema) {\n  const then = FunctionType([Any()], Any());\n  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit(schema.properties['then'], then)) === ExtendsResult.True;\n}\n// ------------------------------------------------------------------\n// Property\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction Property(left, right) {\n  return Visit(left, right) === ExtendsResult.False ? ExtendsResult.False : TypeGuard.IsOptional(left) && !TypeGuard.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;\n}\n// prettier-ignore\nfunction FromObjectRight(left, right) {\n  return TypeGuard.IsUnknown(left) ? ExtendsResult.False : TypeGuard.IsAny(left) ? ExtendsResult.Union : TypeGuard.IsNever(left) || TypeGuard.IsLiteralString(left) && IsObjectStringLike(right) || TypeGuard.IsLiteralNumber(left) && IsObjectNumberLike(right) || TypeGuard.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.IsBigInt(left) && IsObjectBigIntLike(right) || TypeGuard.IsString(left) && IsObjectStringLike(right) || TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.IsNumber(left) && IsObjectNumberLike(right) || TypeGuard.IsInteger(left) && IsObjectNumberLike(right) || TypeGuard.IsBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || TypeGuard.IsDate(left) && IsObjectDateLike(right) || TypeGuard.IsConstructor(left) && IsObjectConstructorLike(right) || TypeGuard.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : TypeGuard.IsRecord(left) && TypeGuard.IsString(RecordKey(left)) ? (() => {\n    // When expressing a Record with literal key values, the Record is converted into a Object with\n    // the Hint assigned as `Record`. This is used to invert the extends logic.\n    return right[Hint] === 'Record' ? ExtendsResult.True : ExtendsResult.False;\n  })() : TypeGuard.IsRecord(left) && TypeGuard.IsNumber(RecordKey(left)) ? (() => {\n    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;\n  })() : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromObject(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : !TypeGuard.IsObject(right) ? ExtendsResult.False : (() => {\n    for (const key of Object.getOwnPropertyNames(right.properties)) {\n      if (!(key in left.properties) && !TypeGuard.IsOptional(right.properties[key])) {\n        return ExtendsResult.False;\n      }\n      if (TypeGuard.IsOptional(right.properties[key])) {\n        return ExtendsResult.True;\n      }\n      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {\n        return ExtendsResult.False;\n      }\n    }\n    return ExtendsResult.True;\n  })();\n}\n// ------------------------------------------------------------------\n// Promise\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromPromise(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !TypeGuard.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.item, right.item));\n}\n// ------------------------------------------------------------------\n// Record\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction RecordKey(schema) {\n  return PatternNumberExact in schema.patternProperties ? Number() : PatternStringExact in schema.patternProperties ? String() : Throw('Unknown record key pattern');\n}\n// prettier-ignore\nfunction RecordValue(schema) {\n  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : PatternStringExact in schema.patternProperties ? schema.patternProperties[PatternStringExact] : Throw('Unable to get record value schema');\n}\n// prettier-ignore\nfunction FromRecordRight(left, right) {\n  const [Key, Value] = [RecordKey(right), RecordValue(right)];\n  return TypeGuard.IsLiteralString(left) && TypeGuard.IsNumber(Key) && IntoBooleanResult(Visit(left, Value)) === ExtendsResult.True ? ExtendsResult.True : TypeGuard.IsUint8Array(left) && TypeGuard.IsNumber(Key) ? Visit(left, Value) : TypeGuard.IsString(left) && TypeGuard.IsNumber(Key) ? Visit(left, Value) : TypeGuard.IsArray(left) && TypeGuard.IsNumber(Key) ? Visit(left, Value) : TypeGuard.IsObject(left) ? (() => {\n    for (const key of Object.getOwnPropertyNames(left.properties)) {\n      if (Property(Value, left.properties[key]) === ExtendsResult.False) {\n        return ExtendsResult.False;\n      }\n    }\n    return ExtendsResult.True;\n  })() : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromRecord(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !TypeGuard.IsRecord(right) ? ExtendsResult.False : Visit(RecordValue(left), RecordValue(right));\n}\n// ------------------------------------------------------------------\n// RegExp\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromRegExp(left, right) {\n  // Note: RegExp types evaluate as strings, not RegExp objects.\n  // Here we remap either into string and continue evaluating.\n  const L = TypeGuard.IsRegExp(left) ? String() : left;\n  const R = TypeGuard.IsRegExp(right) ? String() : right;\n  return Visit(L, R);\n}\n// ------------------------------------------------------------------\n// String\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromStringRight(left, right) {\n  return TypeGuard.IsLiteral(left) && ValueGuard.IsString(left.const) ? ExtendsResult.True : TypeGuard.IsString(left) ? ExtendsResult.True : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromString(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.IsObject(right) ? FromObjectRight(left, right) : TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : TypeGuard.IsString(right) ? ExtendsResult.True : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Symbol\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromSymbol(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.IsObject(right) ? FromObjectRight(left, right) : TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : TypeGuard.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// TemplateLiteral\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromTemplateLiteral(left, right) {\n  // TemplateLiteral types are resolved to either unions for finite expressions or string\n  // for infinite expressions. Here we call to TemplateLiteralResolver to resolve for\n  // either type and continue evaluating.\n  return TypeGuard.IsTemplateLiteral(left) ? Visit(TemplateLiteralToUnion(left), right) : TypeGuard.IsTemplateLiteral(right) ? Visit(left, TemplateLiteralToUnion(right)) : Throw('Invalid fallthrough for TemplateLiteral');\n}\n// ------------------------------------------------------------------\n// Tuple\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsArrayOfTuple(left, right) {\n  return TypeGuard.IsArray(right) && left.items !== undefined && left.items.every(schema => Visit(schema, right.items) === ExtendsResult.True);\n}\n// prettier-ignore\nfunction FromTupleRight(left, right) {\n  return TypeGuard.IsNever(left) ? ExtendsResult.True : TypeGuard.IsUnknown(left) ? ExtendsResult.False : TypeGuard.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromTuple(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : TypeGuard.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !TypeGuard.IsTuple(right) ? ExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) || !ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items) ? ExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Uint8Array\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUint8Array(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.IsObject(right) ? FromObjectRight(left, right) : TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : TypeGuard.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Undefined\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUndefined(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.IsObject(right) ? FromObjectRight(left, right) : TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : TypeGuard.IsVoid(right) ? FromVoidRight(left, right) : TypeGuard.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Union\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUnionRight(left, right) {\n  return right.anyOf.some(schema => Visit(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromUnion(left, right) {\n  return left.anyOf.every(schema => Visit(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Unknown\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUnknownRight(left, right) {\n  return ExtendsResult.True;\n}\n// prettier-ignore\nfunction FromUnknown(left, right) {\n  return TypeGuard.IsNever(right) ? FromNeverRight(left, right) : TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : TypeGuard.IsAny(right) ? FromAnyRight(left, right) : TypeGuard.IsString(right) ? FromStringRight(left, right) : TypeGuard.IsNumber(right) ? FromNumberRight(left, right) : TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) : TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) : TypeGuard.IsArray(right) ? FromArrayRight(left, right) : TypeGuard.IsTuple(right) ? FromTupleRight(left, right) : TypeGuard.IsObject(right) ? FromObjectRight(left, right) : TypeGuard.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Void\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromVoidRight(left, right) {\n  return TypeGuard.IsUndefined(left) ? ExtendsResult.True : TypeGuard.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromVoid(left, right) {\n  return TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) : TypeGuard.IsAny(right) ? FromAnyRight(left, right) : TypeGuard.IsObject(right) ? FromObjectRight(left, right) : TypeGuard.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;\n}\n// prettier-ignore\nfunction Visit(left, right) {\n  return (\n    // resolvable\n    TypeGuard.IsTemplateLiteral(left) || TypeGuard.IsTemplateLiteral(right) ? FromTemplateLiteral(left, right) : TypeGuard.IsRegExp(left) || TypeGuard.IsRegExp(right) ? FromRegExp(left, right) : TypeGuard.IsNot(left) || TypeGuard.IsNot(right) ? FromNot(left, right) :\n    // standard\n    TypeGuard.IsAny(left) ? FromAny(left, right) : TypeGuard.IsArray(left) ? FromArray(left, right) : TypeGuard.IsBigInt(left) ? FromBigInt(left, right) : TypeGuard.IsBoolean(left) ? FromBoolean(left, right) : TypeGuard.IsAsyncIterator(left) ? FromAsyncIterator(left, right) : TypeGuard.IsConstructor(left) ? FromConstructor(left, right) : TypeGuard.IsDate(left) ? FromDate(left, right) : TypeGuard.IsFunction(left) ? FromFunction(left, right) : TypeGuard.IsInteger(left) ? FromInteger(left, right) : TypeGuard.IsIntersect(left) ? FromIntersect(left, right) : TypeGuard.IsIterator(left) ? FromIterator(left, right) : TypeGuard.IsLiteral(left) ? FromLiteral(left, right) : TypeGuard.IsNever(left) ? FromNever(left, right) : TypeGuard.IsNull(left) ? FromNull(left, right) : TypeGuard.IsNumber(left) ? FromNumber(left, right) : TypeGuard.IsObject(left) ? FromObject(left, right) : TypeGuard.IsRecord(left) ? FromRecord(left, right) : TypeGuard.IsString(left) ? FromString(left, right) : TypeGuard.IsSymbol(left) ? FromSymbol(left, right) : TypeGuard.IsTuple(left) ? FromTuple(left, right) : TypeGuard.IsPromise(left) ? FromPromise(left, right) : TypeGuard.IsUint8Array(left) ? FromUint8Array(left, right) : TypeGuard.IsUndefined(left) ? FromUndefined(left, right) : TypeGuard.IsUnion(left) ? FromUnion(left, right) : TypeGuard.IsUnknown(left) ? FromUnknown(left, right) : TypeGuard.IsVoid(left) ? FromVoid(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`)\n  );\n}\nexport function ExtendsCheck(left, right) {\n  return Visit(left, right);\n}","map":{"version":3,"names":["Any","Function","FunctionType","Number","String","Unknown","TemplateLiteralToUnion","PatternNumberExact","PatternStringExact","Kind","Hint","TypeBoxError","TypeGuard","ValueGuard","ExtendsResolverError","ExtendsResult","IntoBooleanResult","result","False","True","Throw","message","IsStructuralRight","right","IsNever","IsIntersect","IsUnion","IsUnknown","IsAny","StructuralRight","left","FromNeverRight","FromIntersectRight","FromUnionRight","FromUnknownRight","FromAnyRight","FromAny","anyOf","some","schema","Union","FromArrayRight","FromArray","IsObject","IsObjectArrayLike","IsArray","Visit","items","FromAsyncIterator","IsAsyncIterator","FromBigInt","FromObjectRight","IsRecord","FromRecordRight","IsBigInt","FromBooleanRight","IsLiteralBoolean","IsBoolean","FromBoolean","FromConstructor","IsConstructor","parameters","length","every","index","returns","FromDate","IsDate","FromFunction","IsFunction","FromIntegerRight","IsLiteral","IsNumber","const","IsInteger","FromInteger","allOf","FromIntersect","FromIterator","IsIterator","FromLiteral","IsString","FromStringRight","FromNumberRight","FromNever","UnwrapTNot","current","depth","IsNot","not","FromNot","FromNull","IsNull","IsLiteralNumber","FromNumber","IsObjectPropertyCount","count","Object","getOwnPropertyNames","properties","IsObjectStringLike","IsObjectSymbolLike","description","IsUndefined","IsObjectNumberLike","IsObjectBooleanLike","IsObjectBigIntLike","IsObjectDateLike","IsObjectUint8ArrayLike","IsObjectFunctionLike","IsObjectConstructorLike","IsObjectPromiseLike","then","Property","IsOptional","IsLiteralString","IsSymbol","IsUint8Array","RecordKey","FromObject","key","FromPromise","IsPromise","item","patternProperties","RecordValue","Key","Value","FromRecord","FromRegExp","L","IsRegExp","R","FromString","FromSymbol","FromTemplateLiteral","IsTemplateLiteral","IsArrayOfTuple","undefined","FromTupleRight","FromTuple","IsTuple","FromUint8Array","FromUndefined","IsVoid","FromVoidRight","FromUnion","FromUnknown","FromVoid","ExtendsCheck"],"sources":["C:/Users/ordon/ThetaFlowz_Cursor/node_modules/yahoo-finance2/node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs"],"sourcesContent":["import { Any } from '../any/index.mjs';\nimport { Function as FunctionType } from '../function/index.mjs';\nimport { Number } from '../number/index.mjs';\nimport { String } from '../string/index.mjs';\nimport { Unknown } from '../unknown/index.mjs';\nimport { TemplateLiteralToUnion } from '../template-literal/index.mjs';\nimport { PatternNumberExact, PatternStringExact } from '../patterns/index.mjs';\nimport { Kind, Hint } from '../symbols/index.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\nimport { TypeGuard, ValueGuard } from '../guard/index.mjs';\nexport class ExtendsResolverError extends TypeBoxError {\n}\nexport var ExtendsResult;\n(function (ExtendsResult) {\n    ExtendsResult[ExtendsResult[\"Union\"] = 0] = \"Union\";\n    ExtendsResult[ExtendsResult[\"True\"] = 1] = \"True\";\n    ExtendsResult[ExtendsResult[\"False\"] = 2] = \"False\";\n})(ExtendsResult || (ExtendsResult = {}));\n// ------------------------------------------------------------------\n// IntoBooleanResult\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IntoBooleanResult(result) {\n    return result === ExtendsResult.False ? result : ExtendsResult.True;\n}\n// ------------------------------------------------------------------\n// Throw\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction Throw(message) {\n    throw new ExtendsResolverError(message);\n}\n// ------------------------------------------------------------------\n// StructuralRight\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsStructuralRight(right) {\n    return (TypeGuard.IsNever(right) ||\n        TypeGuard.IsIntersect(right) ||\n        TypeGuard.IsUnion(right) ||\n        TypeGuard.IsUnknown(right) ||\n        TypeGuard.IsAny(right));\n}\n// prettier-ignore\nfunction StructuralRight(left, right) {\n    return (TypeGuard.IsNever(right) ? FromNeverRight(left, right) :\n        TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :\n            TypeGuard.IsUnion(right) ? FromUnionRight(left, right) :\n                TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) :\n                    TypeGuard.IsAny(right) ? FromAnyRight(left, right) :\n                        Throw('StructuralRight'));\n}\n// ------------------------------------------------------------------\n// Any\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromAnyRight(left, right) {\n    return ExtendsResult.True;\n}\n// prettier-ignore\nfunction FromAny(left, right) {\n    return (TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :\n        (TypeGuard.IsUnion(right) && right.anyOf.some((schema) => TypeGuard.IsAny(schema) || TypeGuard.IsUnknown(schema))) ? ExtendsResult.True :\n            TypeGuard.IsUnion(right) ? ExtendsResult.Union :\n                TypeGuard.IsUnknown(right) ? ExtendsResult.True :\n                    TypeGuard.IsAny(right) ? ExtendsResult.True :\n                        ExtendsResult.Union);\n}\n// ------------------------------------------------------------------\n// Array\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromArrayRight(left, right) {\n    return (TypeGuard.IsUnknown(left) ? ExtendsResult.False :\n        TypeGuard.IsAny(left) ? ExtendsResult.Union :\n            TypeGuard.IsNever(left) ? ExtendsResult.True :\n                ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromArray(left, right) {\n    return (TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True :\n        IsStructuralRight(right) ? StructuralRight(left, right) :\n            !TypeGuard.IsArray(right) ? ExtendsResult.False :\n                IntoBooleanResult(Visit(left.items, right.items)));\n}\n// ------------------------------------------------------------------\n// AsyncIterator\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromAsyncIterator(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        !TypeGuard.IsAsyncIterator(right) ? ExtendsResult.False :\n            IntoBooleanResult(Visit(left.items, right.items)));\n}\n// ------------------------------------------------------------------\n// BigInt\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromBigInt(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsBigInt(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Boolean\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromBooleanRight(left, right) {\n    return (TypeGuard.IsLiteralBoolean(left) ? ExtendsResult.True :\n        TypeGuard.IsBoolean(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromBoolean(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsBoolean(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Constructor\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromConstructor(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            !TypeGuard.IsConstructor(right) ? ExtendsResult.False :\n                left.parameters.length > right.parameters.length ? ExtendsResult.False :\n                    (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True)) ? ExtendsResult.False :\n                        IntoBooleanResult(Visit(left.returns, right.returns)));\n}\n// ------------------------------------------------------------------\n// Date\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromDate(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsDate(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Function\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromFunction(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            !TypeGuard.IsFunction(right) ? ExtendsResult.False :\n                left.parameters.length > right.parameters.length ? ExtendsResult.False :\n                    (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True)) ? ExtendsResult.False :\n                        IntoBooleanResult(Visit(left.returns, right.returns)));\n}\n// ------------------------------------------------------------------\n// Integer\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromIntegerRight(left, right) {\n    return (TypeGuard.IsLiteral(left) && ValueGuard.IsNumber(left.const) ? ExtendsResult.True :\n        TypeGuard.IsNumber(left) || TypeGuard.IsInteger(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromInteger(left, right) {\n    return (TypeGuard.IsInteger(right) || TypeGuard.IsNumber(right) ? ExtendsResult.True :\n        IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n                TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Intersect\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromIntersectRight(left, right) {\n    return right.allOf.every((schema) => Visit(left, schema) === ExtendsResult.True)\n        ? ExtendsResult.True\n        : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromIntersect(left, right) {\n    return left.allOf.some((schema) => Visit(schema, right) === ExtendsResult.True)\n        ? ExtendsResult.True\n        : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Iterator\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromIterator(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        !TypeGuard.IsIterator(right) ? ExtendsResult.False :\n            IntoBooleanResult(Visit(left.items, right.items)));\n}\n// ------------------------------------------------------------------\n// Literal\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromLiteral(left, right) {\n    return (TypeGuard.IsLiteral(right) && right.const === left.const ? ExtendsResult.True :\n        IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n                TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                    TypeGuard.IsString(right) ? FromStringRight(left, right) :\n                        TypeGuard.IsNumber(right) ? FromNumberRight(left, right) :\n                            TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) :\n                                TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) :\n                                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Never\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromNeverRight(left, right) {\n    return ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromNever(left, right) {\n    return ExtendsResult.True;\n}\n// ------------------------------------------------------------------\n// Not\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction UnwrapTNot(schema) {\n    let [current, depth] = [schema, 0];\n    while (true) {\n        if (!TypeGuard.IsNot(current))\n            break;\n        current = current.not;\n        depth += 1;\n    }\n    return depth % 2 === 0 ? current : Unknown();\n}\n// prettier-ignore\nfunction FromNot(left, right) {\n    // TypeScript has no concept of negated types, and attempts to correctly check the negated\n    // type at runtime would put TypeBox at odds with TypeScripts ability to statically infer\n    // the type. Instead we unwrap to either unknown or T and continue evaluating.\n    // prettier-ignore\n    return (TypeGuard.IsNot(left) ? Visit(UnwrapTNot(left), right) :\n        TypeGuard.IsNot(right) ? Visit(left, UnwrapTNot(right)) :\n            Throw('Invalid fallthrough for Not'));\n}\n// ------------------------------------------------------------------\n// Null\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromNull(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsNull(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Number\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromNumberRight(left, right) {\n    return (TypeGuard.IsLiteralNumber(left) ? ExtendsResult.True :\n        TypeGuard.IsNumber(left) || TypeGuard.IsInteger(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromNumber(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsInteger(right) || TypeGuard.IsNumber(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Object\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsObjectPropertyCount(schema, count) {\n    return Object.getOwnPropertyNames(schema.properties).length === count;\n}\n// prettier-ignore\nfunction IsObjectStringLike(schema) {\n    return IsObjectArrayLike(schema);\n}\n// prettier-ignore\nfunction IsObjectSymbolLike(schema) {\n    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && TypeGuard.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && ((TypeGuard.IsString(schema.properties.description.anyOf[0]) &&\n        TypeGuard.IsUndefined(schema.properties.description.anyOf[1])) || (TypeGuard.IsString(schema.properties.description.anyOf[1]) &&\n        TypeGuard.IsUndefined(schema.properties.description.anyOf[0]))));\n}\n// prettier-ignore\nfunction IsObjectNumberLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectBooleanLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectBigIntLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectDateLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectUint8ArrayLike(schema) {\n    return IsObjectArrayLike(schema);\n}\n// prettier-ignore\nfunction IsObjectFunctionLike(schema) {\n    const length = Number();\n    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === ExtendsResult.True);\n}\n// prettier-ignore\nfunction IsObjectConstructorLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectArrayLike(schema) {\n    const length = Number();\n    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === ExtendsResult.True);\n}\n// prettier-ignore\nfunction IsObjectPromiseLike(schema) {\n    const then = FunctionType([Any()], Any());\n    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit(schema.properties['then'], then)) === ExtendsResult.True);\n}\n// ------------------------------------------------------------------\n// Property\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction Property(left, right) {\n    return (Visit(left, right) === ExtendsResult.False ? ExtendsResult.False :\n        TypeGuard.IsOptional(left) && !TypeGuard.IsOptional(right) ? ExtendsResult.False :\n            ExtendsResult.True);\n}\n// prettier-ignore\nfunction FromObjectRight(left, right) {\n    return (TypeGuard.IsUnknown(left) ? ExtendsResult.False :\n        TypeGuard.IsAny(left) ? ExtendsResult.Union : (TypeGuard.IsNever(left) ||\n            (TypeGuard.IsLiteralString(left) && IsObjectStringLike(right)) ||\n            (TypeGuard.IsLiteralNumber(left) && IsObjectNumberLike(right)) ||\n            (TypeGuard.IsLiteralBoolean(left) && IsObjectBooleanLike(right)) ||\n            (TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right)) ||\n            (TypeGuard.IsBigInt(left) && IsObjectBigIntLike(right)) ||\n            (TypeGuard.IsString(left) && IsObjectStringLike(right)) ||\n            (TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right)) ||\n            (TypeGuard.IsNumber(left) && IsObjectNumberLike(right)) ||\n            (TypeGuard.IsInteger(left) && IsObjectNumberLike(right)) ||\n            (TypeGuard.IsBoolean(left) && IsObjectBooleanLike(right)) ||\n            (TypeGuard.IsUint8Array(left) && IsObjectUint8ArrayLike(right)) ||\n            (TypeGuard.IsDate(left) && IsObjectDateLike(right)) ||\n            (TypeGuard.IsConstructor(left) && IsObjectConstructorLike(right)) ||\n            (TypeGuard.IsFunction(left) && IsObjectFunctionLike(right))) ? ExtendsResult.True :\n            (TypeGuard.IsRecord(left) && TypeGuard.IsString(RecordKey(left))) ? (() => {\n                // When expressing a Record with literal key values, the Record is converted into a Object with\n                // the Hint assigned as `Record`. This is used to invert the extends logic.\n                return right[Hint] === 'Record' ? ExtendsResult.True : ExtendsResult.False;\n            })() :\n                (TypeGuard.IsRecord(left) && TypeGuard.IsNumber(RecordKey(left))) ? (() => {\n                    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;\n                })() :\n                    ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromObject(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n            !TypeGuard.IsObject(right) ? ExtendsResult.False :\n                (() => {\n                    for (const key of Object.getOwnPropertyNames(right.properties)) {\n                        if (!(key in left.properties) && !TypeGuard.IsOptional(right.properties[key])) {\n                            return ExtendsResult.False;\n                        }\n                        if (TypeGuard.IsOptional(right.properties[key])) {\n                            return ExtendsResult.True;\n                        }\n                        if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {\n                            return ExtendsResult.False;\n                        }\n                    }\n                    return ExtendsResult.True;\n                })());\n}\n// ------------------------------------------------------------------\n// Promise\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromPromise(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True :\n            !TypeGuard.IsPromise(right) ? ExtendsResult.False :\n                IntoBooleanResult(Visit(left.item, right.item)));\n}\n// ------------------------------------------------------------------\n// Record\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction RecordKey(schema) {\n    return (PatternNumberExact in schema.patternProperties ? Number() :\n        PatternStringExact in schema.patternProperties ? String() :\n            Throw('Unknown record key pattern'));\n}\n// prettier-ignore\nfunction RecordValue(schema) {\n    return (PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] :\n        PatternStringExact in schema.patternProperties ? schema.patternProperties[PatternStringExact] :\n            Throw('Unable to get record value schema'));\n}\n// prettier-ignore\nfunction FromRecordRight(left, right) {\n    const [Key, Value] = [RecordKey(right), RecordValue(right)];\n    return ((TypeGuard.IsLiteralString(left) && TypeGuard.IsNumber(Key) && IntoBooleanResult(Visit(left, Value)) === ExtendsResult.True) ? ExtendsResult.True :\n        TypeGuard.IsUint8Array(left) && TypeGuard.IsNumber(Key) ? Visit(left, Value) :\n            TypeGuard.IsString(left) && TypeGuard.IsNumber(Key) ? Visit(left, Value) :\n                TypeGuard.IsArray(left) && TypeGuard.IsNumber(Key) ? Visit(left, Value) :\n                    TypeGuard.IsObject(left) ? (() => {\n                        for (const key of Object.getOwnPropertyNames(left.properties)) {\n                            if (Property(Value, left.properties[key]) === ExtendsResult.False) {\n                                return ExtendsResult.False;\n                            }\n                        }\n                        return ExtendsResult.True;\n                    })() :\n                        ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromRecord(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            !TypeGuard.IsRecord(right) ? ExtendsResult.False :\n                Visit(RecordValue(left), RecordValue(right)));\n}\n// ------------------------------------------------------------------\n// RegExp\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromRegExp(left, right) {\n    // Note: RegExp types evaluate as strings, not RegExp objects.\n    // Here we remap either into string and continue evaluating.\n    const L = TypeGuard.IsRegExp(left) ? String() : left;\n    const R = TypeGuard.IsRegExp(right) ? String() : right;\n    return Visit(L, R);\n}\n// ------------------------------------------------------------------\n// String\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromStringRight(left, right) {\n    return (TypeGuard.IsLiteral(left) && ValueGuard.IsString(left.const) ? ExtendsResult.True :\n        TypeGuard.IsString(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromString(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsString(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Symbol\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromSymbol(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsSymbol(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// TemplateLiteral\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromTemplateLiteral(left, right) {\n    // TemplateLiteral types are resolved to either unions for finite expressions or string\n    // for infinite expressions. Here we call to TemplateLiteralResolver to resolve for\n    // either type and continue evaluating.\n    return (TypeGuard.IsTemplateLiteral(left) ? Visit(TemplateLiteralToUnion(left), right) :\n        TypeGuard.IsTemplateLiteral(right) ? Visit(left, TemplateLiteralToUnion(right)) :\n            Throw('Invalid fallthrough for TemplateLiteral'));\n}\n// ------------------------------------------------------------------\n// Tuple\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsArrayOfTuple(left, right) {\n    return (TypeGuard.IsArray(right) &&\n        left.items !== undefined &&\n        left.items.every((schema) => Visit(schema, right.items) === ExtendsResult.True));\n}\n// prettier-ignore\nfunction FromTupleRight(left, right) {\n    return (TypeGuard.IsNever(left) ? ExtendsResult.True :\n        TypeGuard.IsUnknown(left) ? ExtendsResult.False :\n            TypeGuard.IsAny(left) ? ExtendsResult.Union :\n                ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromTuple(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True :\n            TypeGuard.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True :\n                !TypeGuard.IsTuple(right) ? ExtendsResult.False :\n                    (ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items)) || (!ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items)) ? ExtendsResult.False :\n                        (ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items)) ? ExtendsResult.True :\n                            left.items.every((schema, index) => Visit(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True :\n                                ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Uint8Array\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUint8Array(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsUint8Array(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Undefined\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUndefined(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsVoid(right) ? FromVoidRight(left, right) :\n                    TypeGuard.IsUndefined(right) ? ExtendsResult.True :\n                        ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Union\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUnionRight(left, right) {\n    return right.anyOf.some((schema) => Visit(left, schema) === ExtendsResult.True)\n        ? ExtendsResult.True\n        : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromUnion(left, right) {\n    return left.anyOf.every((schema) => Visit(schema, right) === ExtendsResult.True)\n        ? ExtendsResult.True\n        : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Unknown\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUnknownRight(left, right) {\n    return ExtendsResult.True;\n}\n// prettier-ignore\nfunction FromUnknown(left, right) {\n    return (TypeGuard.IsNever(right) ? FromNeverRight(left, right) :\n        TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :\n            TypeGuard.IsUnion(right) ? FromUnionRight(left, right) :\n                TypeGuard.IsAny(right) ? FromAnyRight(left, right) :\n                    TypeGuard.IsString(right) ? FromStringRight(left, right) :\n                        TypeGuard.IsNumber(right) ? FromNumberRight(left, right) :\n                            TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) :\n                                TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) :\n                                    TypeGuard.IsArray(right) ? FromArrayRight(left, right) :\n                                        TypeGuard.IsTuple(right) ? FromTupleRight(left, right) :\n                                            TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n                                                TypeGuard.IsUnknown(right) ? ExtendsResult.True :\n                                                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Void\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromVoidRight(left, right) {\n    return (TypeGuard.IsUndefined(left) ? ExtendsResult.True :\n        TypeGuard.IsUndefined(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromVoid(left, right) {\n    return (TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :\n        TypeGuard.IsUnion(right) ? FromUnionRight(left, right) :\n            TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) :\n                TypeGuard.IsAny(right) ? FromAnyRight(left, right) :\n                    TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n                        TypeGuard.IsVoid(right) ? ExtendsResult.True :\n                            ExtendsResult.False);\n}\n// prettier-ignore\nfunction Visit(left, right) {\n    return (\n    // resolvable\n    (TypeGuard.IsTemplateLiteral(left) || TypeGuard.IsTemplateLiteral(right)) ? FromTemplateLiteral(left, right) :\n        (TypeGuard.IsRegExp(left) || TypeGuard.IsRegExp(right)) ? FromRegExp(left, right) :\n            (TypeGuard.IsNot(left) || TypeGuard.IsNot(right)) ? FromNot(left, right) :\n                // standard\n                TypeGuard.IsAny(left) ? FromAny(left, right) :\n                    TypeGuard.IsArray(left) ? FromArray(left, right) :\n                        TypeGuard.IsBigInt(left) ? FromBigInt(left, right) :\n                            TypeGuard.IsBoolean(left) ? FromBoolean(left, right) :\n                                TypeGuard.IsAsyncIterator(left) ? FromAsyncIterator(left, right) :\n                                    TypeGuard.IsConstructor(left) ? FromConstructor(left, right) :\n                                        TypeGuard.IsDate(left) ? FromDate(left, right) :\n                                            TypeGuard.IsFunction(left) ? FromFunction(left, right) :\n                                                TypeGuard.IsInteger(left) ? FromInteger(left, right) :\n                                                    TypeGuard.IsIntersect(left) ? FromIntersect(left, right) :\n                                                        TypeGuard.IsIterator(left) ? FromIterator(left, right) :\n                                                            TypeGuard.IsLiteral(left) ? FromLiteral(left, right) :\n                                                                TypeGuard.IsNever(left) ? FromNever(left, right) :\n                                                                    TypeGuard.IsNull(left) ? FromNull(left, right) :\n                                                                        TypeGuard.IsNumber(left) ? FromNumber(left, right) :\n                                                                            TypeGuard.IsObject(left) ? FromObject(left, right) :\n                                                                                TypeGuard.IsRecord(left) ? FromRecord(left, right) :\n                                                                                    TypeGuard.IsString(left) ? FromString(left, right) :\n                                                                                        TypeGuard.IsSymbol(left) ? FromSymbol(left, right) :\n                                                                                            TypeGuard.IsTuple(left) ? FromTuple(left, right) :\n                                                                                                TypeGuard.IsPromise(left) ? FromPromise(left, right) :\n                                                                                                    TypeGuard.IsUint8Array(left) ? FromUint8Array(left, right) :\n                                                                                                        TypeGuard.IsUndefined(left) ? FromUndefined(left, right) :\n                                                                                                            TypeGuard.IsUnion(left) ? FromUnion(left, right) :\n                                                                                                                TypeGuard.IsUnknown(left) ? FromUnknown(left, right) :\n                                                                                                                    TypeGuard.IsVoid(left) ? FromVoid(left, right) :\n                                                                                                                        Throw(`Unknown left type operand '${left[Kind]}'`));\n}\nexport function ExtendsCheck(left, right) {\n    return Visit(left, right);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}