{"ast":null,"code":"import { TemplateLiteral, TemplateLiteralParseExact, IsTemplateLiteralExpressionFinite, TemplateLiteralExpressionGenerate } from '../template-literal/index.mjs';\nimport { IntrinsicFromMappedKey } from './intrinsic-from-mapped-key.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { Union } from '../union/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedKey, IsTemplateLiteral, IsUnion, IsLiteral } from '../guard/kind.mjs';\n// ------------------------------------------------------------------\n// Apply\n// ------------------------------------------------------------------\nfunction ApplyUncapitalize(value) {\n  const [first, rest] = [value.slice(0, 1), value.slice(1)];\n  return [first.toLowerCase(), rest].join('');\n}\nfunction ApplyCapitalize(value) {\n  const [first, rest] = [value.slice(0, 1), value.slice(1)];\n  return [first.toUpperCase(), rest].join('');\n}\nfunction ApplyUppercase(value) {\n  return value.toUpperCase();\n}\nfunction ApplyLowercase(value) {\n  return value.toLowerCase();\n}\nfunction FromTemplateLiteral(schema, mode, options) {\n  // note: template literals require special runtime handling as they are encoded in string patterns.\n  // This diverges from the mapped type which would otherwise map on the template literal kind.\n  const expression = TemplateLiteralParseExact(schema.pattern);\n  const finite = IsTemplateLiteralExpressionFinite(expression);\n  if (!finite) return {\n    ...schema,\n    pattern: FromLiteralValue(schema.pattern, mode)\n  };\n  const strings = [...TemplateLiteralExpressionGenerate(expression)];\n  const literals = strings.map(value => Literal(value));\n  const mapped = FromRest(literals, mode);\n  const union = Union(mapped);\n  return TemplateLiteral([union], options);\n}\n// prettier-ignore\nfunction FromLiteralValue(value, mode) {\n  return typeof value === 'string' ? mode === 'Uncapitalize' ? ApplyUncapitalize(value) : mode === 'Capitalize' ? ApplyCapitalize(value) : mode === 'Uppercase' ? ApplyUppercase(value) : mode === 'Lowercase' ? ApplyLowercase(value) : value : value.toString();\n}\n// prettier-ignore\nfunction FromRest(T, M) {\n  return T.map(L => Intrinsic(L, M));\n}\n/** Applies an intrinsic string manipulation to the given type. */\nexport function Intrinsic(schema, mode, options = {}) {\n  // prettier-ignore\n  return (\n    // Intrinsic-Mapped-Inference\n    IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) :\n    // Standard-Inference\n    IsTemplateLiteral(schema) ? FromTemplateLiteral(schema, mode, schema) : IsUnion(schema) ? Union(FromRest(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : schema\n  );\n}","map":{"version":3,"names":["TemplateLiteral","TemplateLiteralParseExact","IsTemplateLiteralExpressionFinite","TemplateLiteralExpressionGenerate","IntrinsicFromMappedKey","Literal","Union","IsMappedKey","IsTemplateLiteral","IsUnion","IsLiteral","ApplyUncapitalize","value","first","rest","slice","toLowerCase","join","ApplyCapitalize","toUpperCase","ApplyUppercase","ApplyLowercase","FromTemplateLiteral","schema","mode","options","expression","pattern","finite","FromLiteralValue","strings","literals","map","mapped","FromRest","union","toString","T","M","L","Intrinsic","anyOf","const"],"sources":["C:/Users/ordon/ThetaFlowz_Cursor/node_modules/yahoo-finance2/node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs"],"sourcesContent":["import { TemplateLiteral, TemplateLiteralParseExact, IsTemplateLiteralExpressionFinite, TemplateLiteralExpressionGenerate } from '../template-literal/index.mjs';\nimport { IntrinsicFromMappedKey } from './intrinsic-from-mapped-key.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { Union } from '../union/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedKey, IsTemplateLiteral, IsUnion, IsLiteral } from '../guard/kind.mjs';\n// ------------------------------------------------------------------\n// Apply\n// ------------------------------------------------------------------\nfunction ApplyUncapitalize(value) {\n    const [first, rest] = [value.slice(0, 1), value.slice(1)];\n    return [first.toLowerCase(), rest].join('');\n}\nfunction ApplyCapitalize(value) {\n    const [first, rest] = [value.slice(0, 1), value.slice(1)];\n    return [first.toUpperCase(), rest].join('');\n}\nfunction ApplyUppercase(value) {\n    return value.toUpperCase();\n}\nfunction ApplyLowercase(value) {\n    return value.toLowerCase();\n}\nfunction FromTemplateLiteral(schema, mode, options) {\n    // note: template literals require special runtime handling as they are encoded in string patterns.\n    // This diverges from the mapped type which would otherwise map on the template literal kind.\n    const expression = TemplateLiteralParseExact(schema.pattern);\n    const finite = IsTemplateLiteralExpressionFinite(expression);\n    if (!finite)\n        return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };\n    const strings = [...TemplateLiteralExpressionGenerate(expression)];\n    const literals = strings.map((value) => Literal(value));\n    const mapped = FromRest(literals, mode);\n    const union = Union(mapped);\n    return TemplateLiteral([union], options);\n}\n// prettier-ignore\nfunction FromLiteralValue(value, mode) {\n    return (typeof value === 'string' ? (mode === 'Uncapitalize' ? ApplyUncapitalize(value) :\n        mode === 'Capitalize' ? ApplyCapitalize(value) :\n            mode === 'Uppercase' ? ApplyUppercase(value) :\n                mode === 'Lowercase' ? ApplyLowercase(value) :\n                    value) : value.toString());\n}\n// prettier-ignore\nfunction FromRest(T, M) {\n    return T.map(L => Intrinsic(L, M));\n}\n/** Applies an intrinsic string manipulation to the given type. */\nexport function Intrinsic(schema, mode, options = {}) {\n    // prettier-ignore\n    return (\n    // Intrinsic-Mapped-Inference\n    IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) :\n        // Standard-Inference\n        IsTemplateLiteral(schema) ? FromTemplateLiteral(schema, mode, schema) :\n            IsUnion(schema) ? Union(FromRest(schema.anyOf, mode), options) :\n                IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) :\n                    schema);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}