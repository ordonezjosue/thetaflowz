{"ast":null,"code":"import { Type } from \"@sinclair/typebox\";\nimport { Value } from \"@sinclair/typebox/value\";\nimport { YahooFinanceDate, YahooNumber } from \"../lib/yahooFinanceTypes.js\";\nimport { ChartOptionsSchema } from \"./chart.js\";\nimport validateAndCoerceTypebox from \"../lib/validateAndCoerceTypes.js\";\nimport { showNotice } from \"../lib/notices.js\";\nconst HistoricalRowHistorySchema = Type.Object({\n  date: YahooFinanceDate,\n  open: YahooNumber,\n  high: YahooNumber,\n  low: YahooNumber,\n  close: YahooNumber,\n  adjClose: Type.Optional(YahooNumber),\n  volume: YahooNumber\n}, {\n  additionalProperties: Type.Any(),\n  title: \"HistoricalRowHistory\"\n});\nconst HistoricalRowDividendSchema = Type.Object({\n  date: YahooFinanceDate,\n  dividends: YahooNumber\n}, {\n  title: \"HistoricalRowDividend\"\n});\nconst HistoricalRowStockSplitSchema = Type.Object({\n  date: YahooFinanceDate,\n  stockSplits: Type.String()\n}, {\n  title: \"HistoricalRowStockSplit\"\n});\nconst HistoricalOptionsSchema = Type.Object({\n  period1: Type.Union([Type.Date(), Type.String(), Type.Number()]),\n  period2: Type.Optional(Type.Union([Type.Date(), Type.String(), Type.Number()])),\n  interval: Type.Optional(Type.Union([Type.Literal(\"1d\"), Type.Literal(\"1wk\"), Type.Literal(\"1mo\")])),\n  // events: Type.Optional(Type.String()),\n  events: Type.Optional(Type.Union([Type.Literal(\"history\"), Type.Literal(\"dividends\"), Type.Literal(\"split\")])),\n  includeAdjustedClose: Type.Optional(Type.Boolean())\n}, {\n  title: \"HistoricalOptions\"\n});\nconst HistoricalOptionsEventsHistorySchema = Type.Composite([HistoricalOptionsSchema, Type.Object({\n  events: Type.Optional(Type.Literal(\"history\"))\n})], {\n  title: \"HistoricalOptionsEventsHistory\"\n});\nconst HistoricalOptionsEventsDividendsSchema = Type.Composite([HistoricalOptionsSchema, Type.Object({\n  events: Type.Literal(\"dividends\")\n})], {\n  title: \"HistoricalOptionsEventsDividends\"\n});\nconst HistoricalOptionsEventsSplitSchema = Type.Composite([HistoricalOptionsSchema, Type.Object({\n  events: Type.Literal(\"split\")\n})], {\n  title: \"HistoricalOptionsEventsSplit\"\n});\nconst HistoricalHistoryResultSchema = Type.Array(HistoricalRowHistorySchema, {\n  title: \"HistoricalHistoryResult\"\n});\nconst HistoricalDividendsResultSchema = Type.Array(HistoricalRowDividendSchema, {\n  title: \"HistoricalDividendsResult\"\n});\nconst HistoricalStockSplitsResultSchema = Type.Array(HistoricalRowStockSplitSchema, {\n  title: \"HistoricalRowStockSplit\"\n});\nconst queryOptionsDefaults = {\n  interval: \"1d\",\n  events: \"history\",\n  includeAdjustedClose: true\n};\n// Count number of null values in object (1-level deep)\nfunction nullFieldCount(object) {\n  if (object == null) {\n    return;\n  }\n  let nullCount = 0;\n  for (const val of Object.values(object)) if (val === null) nullCount++;\n  return nullCount;\n}\nexport default async function historical(symbol, queryOptionsOverrides, moduleOptions) {\n  var _a, _b, _c, _d, _e;\n  showNotice(\"ripHistorical\");\n  validateAndCoerceTypebox({\n    type: \"options\",\n    data: queryOptionsOverrides !== null && queryOptionsOverrides !== void 0 ? queryOptionsOverrides : {},\n    schema: HistoricalOptionsSchema,\n    options: this._opts.validation\n  });\n  let schema;\n  if (!queryOptionsOverrides.events || queryOptionsOverrides.events === \"history\") schema = HistoricalHistoryResultSchema;else if (queryOptionsOverrides.events === \"dividends\") schema = HistoricalDividendsResultSchema;else if (queryOptionsOverrides.events === \"split\") schema = HistoricalStockSplitsResultSchema;else throw new Error(\"No such event type:\" + queryOptionsOverrides.events);\n  const queryOpts = {\n    ...queryOptionsDefaults,\n    ...queryOptionsOverrides\n  };\n  if (!Value.Check(HistoricalOptionsSchema, queryOpts)) throw new Error(\"Internal error, please report.  Overrides validated but not defaults?\");\n  // Don't forget that queryOpts are already validated and safe-safe.\n  const eventsMap = {\n    history: \"\",\n    dividends: \"div\",\n    split: \"split\"\n  };\n  const chartQueryOpts = {\n    period1: queryOpts.period1,\n    period2: queryOpts.period2,\n    interval: queryOpts.interval,\n    events: eventsMap[queryOpts.events || \"history\"]\n  };\n  if (!Value.Check(ChartOptionsSchema, chartQueryOpts)) throw new Error(\"Internal error, please report.  historical() provided invalid chart() query options.\");\n  // TODO: do we even care?\n  if (queryOpts.includeAdjustedClose === false) {\n    /* */\n  }\n  const result = await this.chart(symbol, chartQueryOpts, {\n    ...moduleOptions,\n    validateResult: true\n  });\n  let out;\n  if (queryOpts.events === \"dividends\") {\n    out = ((_b = (_a = result.events) === null || _a === void 0 ? void 0 : _a.dividends) !== null && _b !== void 0 ? _b : []).map(d => ({\n      date: d.date,\n      dividends: d.amount\n    }));\n  } else if (queryOpts.events === \"split\") {\n    out = ((_d = (_c = result.events) === null || _c === void 0 ? void 0 : _c.splits) !== null && _d !== void 0 ? _d : []).map(s => ({\n      date: s.date,\n      stockSplits: s.splitRatio\n    }));\n  } else {\n    out = ((_e = result.quotes) !== null && _e !== void 0 ? _e : []).filter(quote => {\n      const fieldCount = Object.keys(quote).length;\n      const nullCount = nullFieldCount(quote);\n      if (nullCount === 0) {\n        // No nulls is a legit (regular) result\n        return true;\n      } else if (nullCount !== fieldCount - 1 /* skip \"date\" */) {\n        // Unhandled case: some but not all values are null.\n        // Note: no need to check for null \"date\", validation does it for us\n        console.error(nullCount, quote);\n        throw new Error(\"Historical returned a result with SOME (but not \" + \"all) null values.  Please report this, and provide the \" + \"query that caused it.\");\n      } else {\n        // All fields (except \"date\") are null\n        return false;\n      }\n    }).map(quote => {\n      if (!quote.adjclose) return quote;\n      const {\n        adjclose,\n        ...rest\n      } = quote;\n      return {\n        ...rest,\n        adjClose: adjclose\n      };\n    });\n  }\n  const validateResult = !moduleOptions || moduleOptions.validateResult === undefined || moduleOptions.validateResult === true;\n  const validationOpts = {\n    ...this._opts.validation,\n    // Set logErrors=false if validateResult=false\n    logErrors: validateResult ? this._opts.validation.logErrors : false\n  };\n  try {\n    return validateAndCoerceTypebox({\n      type: \"result\",\n      data: out,\n      schema,\n      options: validationOpts\n    });\n  } catch (error) {\n    if (validateResult) throw error;\n  }\n  return out;\n  /*\n  // Original historical() retrieval code when Yahoo API still existed.\n  return this._moduleExec({\n    moduleName: \"historical\",\n       query: {\n      assertSymbol: symbol,\n      url: \"https://${YF_QUERY_HOST}/v7/finance/download/\" + symbol,\n      schema: HistoricalOptionsSchema,\n      defaults: queryOptionsDefaults,\n      overrides: queryOptionsOverrides,\n      fetchType: \"csv\",\n      transformWith(queryOptions: HistoricalOptions) {\n        if (!queryOptions.period2) queryOptions.period2 = new Date();\n           const dates = [\"period1\", \"period2\"] as const;\n        for (const fieldName of dates) {\n          const value = queryOptions[fieldName];\n          if (value instanceof Date)\n            queryOptions[fieldName] = Math.floor(value.getTime() / 1000);\n          else if (typeof value === \"string\") {\n            const timestamp = new Date(value as string).getTime();\n               if (isNaN(timestamp))\n              throw new Error(\n                \"yahooFinance.historical() option '\" +\n                  fieldName +\n                  \"' invalid date provided: '\" +\n                  value +\n                  \"'\",\n              );\n               queryOptions[fieldName] = Math.floor(timestamp / 1000);\n          }\n        }\n           if (queryOptions.period1 === queryOptions.period2) {\n          throw new Error(\n            \"yahooFinance.historical() options `period1` and `period2` \" +\n              \"cannot share the same value.\",\n          );\n        }\n           return queryOptions;\n      },\n    },\n       result: {\n      schema,\n      transformWith(result: any) {\n        if (result.length === 0) return result;\n           const filteredResults = [];\n        const fieldCount = Object.keys(result[0]).length;\n           // Count number of null values in object (1-level deep)\n        function nullFieldCount(object: unknown) {\n          if (object == null) {\n            return;\n          }\n          let nullCount = 0;\n          for (const val of Object.values(object))\n            if (val === null) nullCount++;\n          return nullCount;\n        }\n           for (const row of result) {\n          const nullCount = nullFieldCount(row);\n             if (nullCount === 0) {\n            // No nulls is a legit (regular) result\n            filteredResults.push(row);\n          } else if (nullCount !== fieldCount - 1 /* skip \"date\" */ /*) {\n                                                                    // Unhandled case: some but not all values are null.\n                                                                    // Note: no need to check for null \"date\", validation does it for us\n                                                                    console.error(nullCount, row);\n                                                                    throw new Error(\n                                                                    \"Historical returned a result with SOME (but not \" +\n                                                                    \"all) null values.  Please report this, and provide the \" +\n                                                                    \"query that caused it.\",\n                                                                    );\n                                                                    } else {\n                                                                    // All fields (except \"date\") are null: silently skip (no-op)\n                                                                    }\n                                                                    }\n                                                                    /*\n                                                                    * We may consider, for future optimization, to count rows and create\n                                                                    * new array in advance, and skip consecutive blocks of null results.\n                                                                    * Of doubtful utility.\n                                                                    */ /*\n                                                                       return filteredResults;\n                                                                       },\n                                                                       },\n                                                                       moduleOptions,\n                                                                       });\n                                                                       */\n}","map":{"version":3,"names":["Type","Value","YahooFinanceDate","YahooNumber","ChartOptionsSchema","validateAndCoerceTypebox","showNotice","HistoricalRowHistorySchema","Object","date","open","high","low","close","adjClose","Optional","volume","additionalProperties","Any","title","HistoricalRowDividendSchema","dividends","HistoricalRowStockSplitSchema","stockSplits","String","HistoricalOptionsSchema","period1","Union","Date","Number","period2","interval","Literal","events","includeAdjustedClose","Boolean","HistoricalOptionsEventsHistorySchema","Composite","HistoricalOptionsEventsDividendsSchema","HistoricalOptionsEventsSplitSchema","HistoricalHistoryResultSchema","Array","HistoricalDividendsResultSchema","HistoricalStockSplitsResultSchema","queryOptionsDefaults","nullFieldCount","object","nullCount","val","values","historical","symbol","queryOptionsOverrides","moduleOptions","_a","_b","_c","_d","_e","type","data","schema","options","_opts","validation","Error","queryOpts","Check","eventsMap","history","split","chartQueryOpts","result","chart","validateResult","out","map","d","amount","splits","s","splitRatio","quotes","filter","quote","fieldCount","keys","length","console","error","adjclose","rest","undefined","validationOpts","logErrors"],"sources":["C:/Users/ordon/ThetaFlowz_Cursor/node_modules/yahoo-finance2/dist/esm/src/modules/historical.js"],"sourcesContent":["import { Type } from \"@sinclair/typebox\";\nimport { Value } from \"@sinclair/typebox/value\";\nimport { YahooFinanceDate, YahooNumber } from \"../lib/yahooFinanceTypes.js\";\nimport { ChartOptionsSchema } from \"./chart.js\";\nimport validateAndCoerceTypebox from \"../lib/validateAndCoerceTypes.js\";\nimport { showNotice } from \"../lib/notices.js\";\nconst HistoricalRowHistorySchema = Type.Object({\n    date: YahooFinanceDate,\n    open: YahooNumber,\n    high: YahooNumber,\n    low: YahooNumber,\n    close: YahooNumber,\n    adjClose: Type.Optional(YahooNumber),\n    volume: YahooNumber,\n}, {\n    additionalProperties: Type.Any(),\n    title: \"HistoricalRowHistory\",\n});\nconst HistoricalRowDividendSchema = Type.Object({\n    date: YahooFinanceDate,\n    dividends: YahooNumber,\n}, { title: \"HistoricalRowDividend\" });\nconst HistoricalRowStockSplitSchema = Type.Object({\n    date: YahooFinanceDate,\n    stockSplits: Type.String(),\n}, { title: \"HistoricalRowStockSplit\" });\nconst HistoricalOptionsSchema = Type.Object({\n    period1: Type.Union([Type.Date(), Type.String(), Type.Number()]),\n    period2: Type.Optional(Type.Union([Type.Date(), Type.String(), Type.Number()])),\n    interval: Type.Optional(Type.Union([\n        Type.Literal(\"1d\"),\n        Type.Literal(\"1wk\"),\n        Type.Literal(\"1mo\"),\n    ])),\n    // events: Type.Optional(Type.String()),\n    events: Type.Optional(Type.Union([\n        Type.Literal(\"history\"),\n        Type.Literal(\"dividends\"),\n        Type.Literal(\"split\"),\n    ])),\n    includeAdjustedClose: Type.Optional(Type.Boolean()),\n}, { title: \"HistoricalOptions\" });\nconst HistoricalOptionsEventsHistorySchema = Type.Composite([\n    HistoricalOptionsSchema,\n    Type.Object({\n        events: Type.Optional(Type.Literal(\"history\")),\n    }),\n], { title: \"HistoricalOptionsEventsHistory\" });\nconst HistoricalOptionsEventsDividendsSchema = Type.Composite([\n    HistoricalOptionsSchema,\n    Type.Object({\n        events: Type.Literal(\"dividends\"),\n    }),\n], { title: \"HistoricalOptionsEventsDividends\" });\nconst HistoricalOptionsEventsSplitSchema = Type.Composite([\n    HistoricalOptionsSchema,\n    Type.Object({\n        events: Type.Literal(\"split\"),\n    }),\n], { title: \"HistoricalOptionsEventsSplit\" });\nconst HistoricalHistoryResultSchema = Type.Array(HistoricalRowHistorySchema, {\n    title: \"HistoricalHistoryResult\",\n});\nconst HistoricalDividendsResultSchema = Type.Array(HistoricalRowDividendSchema, {\n    title: \"HistoricalDividendsResult\",\n});\nconst HistoricalStockSplitsResultSchema = Type.Array(HistoricalRowStockSplitSchema, {\n    title: \"HistoricalRowStockSplit\",\n});\nconst queryOptionsDefaults = {\n    interval: \"1d\",\n    events: \"history\",\n    includeAdjustedClose: true,\n};\n// Count number of null values in object (1-level deep)\nfunction nullFieldCount(object) {\n    if (object == null) {\n        return;\n    }\n    let nullCount = 0;\n    for (const val of Object.values(object))\n        if (val === null)\n            nullCount++;\n    return nullCount;\n}\nexport default async function historical(symbol, queryOptionsOverrides, moduleOptions) {\n    var _a, _b, _c, _d, _e;\n    showNotice(\"ripHistorical\");\n    validateAndCoerceTypebox({\n        type: \"options\",\n        data: queryOptionsOverrides !== null && queryOptionsOverrides !== void 0 ? queryOptionsOverrides : {},\n        schema: HistoricalOptionsSchema,\n        options: this._opts.validation,\n    });\n    let schema;\n    if (!queryOptionsOverrides.events ||\n        queryOptionsOverrides.events === \"history\")\n        schema = HistoricalHistoryResultSchema;\n    else if (queryOptionsOverrides.events === \"dividends\")\n        schema = HistoricalDividendsResultSchema;\n    else if (queryOptionsOverrides.events === \"split\")\n        schema = HistoricalStockSplitsResultSchema;\n    else\n        throw new Error(\"No such event type:\" + queryOptionsOverrides.events);\n    const queryOpts = { ...queryOptionsDefaults, ...queryOptionsOverrides };\n    if (!Value.Check(HistoricalOptionsSchema, queryOpts))\n        throw new Error(\"Internal error, please report.  Overrides validated but not defaults?\");\n    // Don't forget that queryOpts are already validated and safe-safe.\n    const eventsMap = { history: \"\", dividends: \"div\", split: \"split\" };\n    const chartQueryOpts = {\n        period1: queryOpts.period1,\n        period2: queryOpts.period2,\n        interval: queryOpts.interval,\n        events: eventsMap[queryOpts.events || \"history\"],\n    };\n    if (!Value.Check(ChartOptionsSchema, chartQueryOpts))\n        throw new Error(\"Internal error, please report.  historical() provided invalid chart() query options.\");\n    // TODO: do we even care?\n    if (queryOpts.includeAdjustedClose === false) {\n        /* */\n    }\n    const result = await this.chart(symbol, chartQueryOpts, {\n        ...moduleOptions,\n        validateResult: true,\n    });\n    let out;\n    if (queryOpts.events === \"dividends\") {\n        out = ((_b = (_a = result.events) === null || _a === void 0 ? void 0 : _a.dividends) !== null && _b !== void 0 ? _b : []).map((d) => ({\n            date: d.date,\n            dividends: d.amount,\n        }));\n    }\n    else if (queryOpts.events === \"split\") {\n        out = ((_d = (_c = result.events) === null || _c === void 0 ? void 0 : _c.splits) !== null && _d !== void 0 ? _d : []).map((s) => ({\n            date: s.date,\n            stockSplits: s.splitRatio,\n        }));\n    }\n    else {\n        out = ((_e = result.quotes) !== null && _e !== void 0 ? _e : [])\n            .filter((quote) => {\n            const fieldCount = Object.keys(quote).length;\n            const nullCount = nullFieldCount(quote);\n            if (nullCount === 0) {\n                // No nulls is a legit (regular) result\n                return true;\n            }\n            else if (nullCount !== fieldCount - 1 /* skip \"date\" */) {\n                // Unhandled case: some but not all values are null.\n                // Note: no need to check for null \"date\", validation does it for us\n                console.error(nullCount, quote);\n                throw new Error(\"Historical returned a result with SOME (but not \" +\n                    \"all) null values.  Please report this, and provide the \" +\n                    \"query that caused it.\");\n            }\n            else {\n                // All fields (except \"date\") are null\n                return false;\n            }\n        })\n            .map((quote) => {\n            if (!quote.adjclose)\n                return quote;\n            const { adjclose, ...rest } = quote;\n            return { ...rest, adjClose: adjclose };\n        });\n    }\n    const validateResult = !moduleOptions ||\n        moduleOptions.validateResult === undefined ||\n        moduleOptions.validateResult === true;\n    const validationOpts = {\n        ...this._opts.validation,\n        // Set logErrors=false if validateResult=false\n        logErrors: validateResult ? this._opts.validation.logErrors : false,\n    };\n    try {\n        return validateAndCoerceTypebox({\n            type: \"result\",\n            data: out,\n            schema,\n            options: validationOpts,\n        });\n    }\n    catch (error) {\n        if (validateResult)\n            throw error;\n    }\n    return out;\n    /*\n    // Original historical() retrieval code when Yahoo API still existed.\n    return this._moduleExec({\n      moduleName: \"historical\",\n  \n      query: {\n        assertSymbol: symbol,\n        url: \"https://${YF_QUERY_HOST}/v7/finance/download/\" + symbol,\n        schema: HistoricalOptionsSchema,\n        defaults: queryOptionsDefaults,\n        overrides: queryOptionsOverrides,\n        fetchType: \"csv\",\n        transformWith(queryOptions: HistoricalOptions) {\n          if (!queryOptions.period2) queryOptions.period2 = new Date();\n  \n          const dates = [\"period1\", \"period2\"] as const;\n          for (const fieldName of dates) {\n            const value = queryOptions[fieldName];\n            if (value instanceof Date)\n              queryOptions[fieldName] = Math.floor(value.getTime() / 1000);\n            else if (typeof value === \"string\") {\n              const timestamp = new Date(value as string).getTime();\n  \n              if (isNaN(timestamp))\n                throw new Error(\n                  \"yahooFinance.historical() option '\" +\n                    fieldName +\n                    \"' invalid date provided: '\" +\n                    value +\n                    \"'\",\n                );\n  \n              queryOptions[fieldName] = Math.floor(timestamp / 1000);\n            }\n          }\n  \n          if (queryOptions.period1 === queryOptions.period2) {\n            throw new Error(\n              \"yahooFinance.historical() options `period1` and `period2` \" +\n                \"cannot share the same value.\",\n            );\n          }\n  \n          return queryOptions;\n        },\n      },\n  \n      result: {\n        schema,\n        transformWith(result: any) {\n          if (result.length === 0) return result;\n  \n          const filteredResults = [];\n          const fieldCount = Object.keys(result[0]).length;\n  \n          // Count number of null values in object (1-level deep)\n          function nullFieldCount(object: unknown) {\n            if (object == null) {\n              return;\n            }\n            let nullCount = 0;\n            for (const val of Object.values(object))\n              if (val === null) nullCount++;\n            return nullCount;\n          }\n  \n          for (const row of result) {\n            const nullCount = nullFieldCount(row);\n  \n            if (nullCount === 0) {\n              // No nulls is a legit (regular) result\n              filteredResults.push(row);\n            } else if (nullCount !== fieldCount - 1 /* skip \"date\" */ /*) {\n      // Unhandled case: some but not all values are null.\n      // Note: no need to check for null \"date\", validation does it for us\n      console.error(nullCount, row);\n      throw new Error(\n        \"Historical returned a result with SOME (but not \" +\n          \"all) null values.  Please report this, and provide the \" +\n          \"query that caused it.\",\n      );\n    } else {\n      // All fields (except \"date\") are null: silently skip (no-op)\n    }\n  }\n\n  /*\n   * We may consider, for future optimization, to count rows and create\n   * new array in advance, and skip consecutive blocks of null results.\n   * Of doubtful utility.\n   */ /*\n   return filteredResults;\n },\n},\n\nmoduleOptions,\n});\n*/\n}\n"],"mappings":"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,IAC1CvC,aAAa,CAACqB,cAAc,KAAK,IAAI;EACzC,MAAMmB,cAAc,GAAG;IACnB,GAAG,IAAI,CAAC9B,KAAK,CAACC,UAAU;IACxB;IACA8B,SAAS,EAAEpB,cAAc,GAAG,IAAI,CAACX,KAAK,CAACC,UAAU,CAAC8B,SAAS,GAAG;EAClE,CAAC;EACD,IAAI;IACA,OAAOzF,wBAAwB,CAAC;MAC5BsD,IAAI,EAAE,QAAQ;MACdC,IAAI,EAAEe,GAAG;MACTd,MAAM;MACNC,OAAO,EAAE+B;IACb,CAAC,CAAC;EACN,CAAC,CACD,OAAOJ,KAAK,EAAE;IACV,IAAIf,cAAc,EACd,MAAMe,KAAK;EACnB;EACA,OAAOd,GAAG;EACV;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEA7DI,CAwEkE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAjBsE,CAkBhE;AACN;AACA;AACA;AACA;AACA;AACA;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}