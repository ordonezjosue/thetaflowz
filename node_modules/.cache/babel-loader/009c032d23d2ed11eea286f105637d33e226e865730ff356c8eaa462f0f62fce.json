{"ast":null,"code":"import { HasPropertyKey, IsString } from '../guard/index.mjs';\nimport { Check } from '../check/index.mjs';\nimport { Clone } from '../clone/index.mjs';\nimport { Deref } from '../deref/index.mjs';\nimport { TemplateLiteralGenerate, IsTemplateLiteralFinite } from '../../type/template-literal/index.mjs';\nimport { PatternStringExact, PatternNumberExact } from '../../type/patterns/index.mjs';\nimport { TypeRegistry } from '../../type/registry/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValueCreateError extends TypeBoxError {\n  constructor(schema, message) {\n    super(message);\n    this.schema = schema;\n  }\n}\n// ------------------------------------------------------------------\n// Default\n// ------------------------------------------------------------------\nfunction FromDefault(value) {\n  return typeof value === 'function' ? value : Clone(value);\n}\n// ------------------------------------------------------------------\n// Create\n// ------------------------------------------------------------------\nfunction FromAny(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    return {};\n  }\n}\nfunction FromArray(schema, references) {\n  if (schema.uniqueItems === true && !HasPropertyKey(schema, 'default')) {\n    throw new ValueCreateError(schema, 'Array with the uniqueItems constraint requires a default value');\n  } else if ('contains' in schema && !HasPropertyKey(schema, 'default')) {\n    throw new ValueCreateError(schema, 'Array with the contains constraint requires a default value');\n  } else if ('default' in schema) {\n    return FromDefault(schema.default);\n  } else if (schema.minItems !== undefined) {\n    return Array.from({\n      length: schema.minItems\n    }).map(item => {\n      return Visit(schema.items, references);\n    });\n  } else {\n    return [];\n  }\n}\nfunction FromAsyncIterator(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    return async function* () {}();\n  }\n}\nfunction FromBigInt(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    return BigInt(0);\n  }\n}\nfunction FromBoolean(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    return false;\n  }\n}\nfunction FromConstructor(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    const value = Visit(schema.returns, references);\n    if (typeof value === 'object' && !Array.isArray(value)) {\n      return class {\n        constructor() {\n          for (const [key, val] of Object.entries(value)) {\n            const self = this;\n            self[key] = val;\n          }\n        }\n      };\n    } else {\n      return class {};\n    }\n  }\n}\nfunction FromDate(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else if (schema.minimumTimestamp !== undefined) {\n    return new Date(schema.minimumTimestamp);\n  } else {\n    return new Date();\n  }\n}\nfunction FromFunction(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    return () => Visit(schema.returns, references);\n  }\n}\nfunction FromInteger(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else if (schema.minimum !== undefined) {\n    return schema.minimum;\n  } else {\n    return 0;\n  }\n}\nfunction FromIntersect(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    // --------------------------------------------------------------\n    // Note: The best we can do here is attempt to instance each\n    // sub type and apply through object assign. For non-object\n    // sub types, we just escape the assignment and just return\n    // the value. In the latter case, this is typically going to\n    // be a consequence of an illogical intersection.\n    // --------------------------------------------------------------\n    const value = schema.allOf.reduce((acc, schema) => {\n      const next = Visit(schema, references);\n      return typeof next === 'object' ? {\n        ...acc,\n        ...next\n      } : next;\n    }, {});\n    if (!Check(schema, references, value)) throw new ValueCreateError(schema, 'Intersect produced invalid value. Consider using a default value.');\n    return value;\n  }\n}\nfunction FromIterator(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    return function* () {}();\n  }\n}\nfunction FromLiteral(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    return schema.const;\n  }\n}\nfunction FromNever(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    throw new ValueCreateError(schema, 'Never types cannot be created. Consider using a default value.');\n  }\n}\nfunction FromNot(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    throw new ValueCreateError(schema, 'Not types must have a default value');\n  }\n}\nfunction FromNull(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    return null;\n  }\n}\nfunction FromNumber(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else if (schema.minimum !== undefined) {\n    return schema.minimum;\n  } else {\n    return 0;\n  }\n}\nfunction FromObject(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    const required = new Set(schema.required);\n    const Acc = {};\n    for (const [key, subschema] of Object.entries(schema.properties)) {\n      if (!required.has(key)) continue;\n      Acc[key] = Visit(subschema, references);\n    }\n    return Acc;\n  }\n}\nfunction FromPromise(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    return Promise.resolve(Visit(schema.item, references));\n  }\n}\nfunction FromRecord(schema, references) {\n  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {\n    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split('|');\n    const Acc = {};\n    for (const key of propertyKeys) Acc[key] = Visit(valueSchema, references);\n    return Acc;\n  } else {\n    return {};\n  }\n}\nfunction FromRef(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    return Visit(Deref(schema, references), references);\n  }\n}\nfunction FromRegExp(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    throw new ValueCreateError(schema, 'RegExp types cannot be created. Consider using a default value.');\n  }\n}\nfunction FromString(schema, references) {\n  if (schema.pattern !== undefined) {\n    if (!HasPropertyKey(schema, 'default')) {\n      throw new ValueCreateError(schema, 'String types with patterns must specify a default value');\n    } else {\n      return FromDefault(schema.default);\n    }\n  } else if (schema.format !== undefined) {\n    if (!HasPropertyKey(schema, 'default')) {\n      throw new ValueCreateError(schema, 'String types with formats must specify a default value');\n    } else {\n      return FromDefault(schema.default);\n    }\n  } else {\n    if (HasPropertyKey(schema, 'default')) {\n      return FromDefault(schema.default);\n    } else if (schema.minLength !== undefined) {\n      // prettier-ignore\n      return Array.from({\n        length: schema.minLength\n      }).map(() => ' ').join('');\n    } else {\n      return '';\n    }\n  }\n}\nfunction FromSymbol(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else if ('value' in schema) {\n    return Symbol.for(schema.value);\n  } else {\n    return Symbol();\n  }\n}\nfunction FromTemplateLiteral(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  }\n  if (!IsTemplateLiteralFinite(schema)) throw new ValueCreateError(schema, 'Can only create template literals that produce a finite variants. Consider using a default value.');\n  const generated = TemplateLiteralGenerate(schema);\n  return generated[0];\n}\nfunction FromThis(schema, references) {\n  if (recursiveDepth++ > recursiveMaxDepth) throw new ValueCreateError(schema, 'Cannot create recursive type as it appears possibly infinite. Consider using a default.');\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    return Visit(Deref(schema, references), references);\n  }\n}\nfunction FromTuple(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  }\n  if (schema.items === undefined) {\n    return [];\n  } else {\n    return Array.from({\n      length: schema.minItems\n    }).map((_, index) => Visit(schema.items[index], references));\n  }\n}\nfunction FromUndefined(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    return undefined;\n  }\n}\nfunction FromUnion(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else if (schema.anyOf.length === 0) {\n    throw new Error('ValueCreate.Union: Cannot create Union with zero variants');\n  } else {\n    return Visit(schema.anyOf[0], references);\n  }\n}\nfunction FromUint8Array(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else if (schema.minByteLength !== undefined) {\n    return new Uint8Array(schema.minByteLength);\n  } else {\n    return new Uint8Array(0);\n  }\n}\nfunction FromUnknown(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    return {};\n  }\n}\nfunction FromVoid(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    return void 0;\n  }\n}\nfunction FromKind(schema, references) {\n  if (HasPropertyKey(schema, 'default')) {\n    return FromDefault(schema.default);\n  } else {\n    throw new Error('User defined types must specify a default value');\n  }\n}\nfunction Visit(schema, references) {\n  const references_ = IsString(schema.$id) ? [...references, schema] : references;\n  const schema_ = schema;\n  switch (schema_[Kind]) {\n    case 'Any':\n      return FromAny(schema_, references_);\n    case 'Array':\n      return FromArray(schema_, references_);\n    case 'AsyncIterator':\n      return FromAsyncIterator(schema_, references_);\n    case 'BigInt':\n      return FromBigInt(schema_, references_);\n    case 'Boolean':\n      return FromBoolean(schema_, references_);\n    case 'Constructor':\n      return FromConstructor(schema_, references_);\n    case 'Date':\n      return FromDate(schema_, references_);\n    case 'Function':\n      return FromFunction(schema_, references_);\n    case 'Integer':\n      return FromInteger(schema_, references_);\n    case 'Intersect':\n      return FromIntersect(schema_, references_);\n    case 'Iterator':\n      return FromIterator(schema_, references_);\n    case 'Literal':\n      return FromLiteral(schema_, references_);\n    case 'Never':\n      return FromNever(schema_, references_);\n    case 'Not':\n      return FromNot(schema_, references_);\n    case 'Null':\n      return FromNull(schema_, references_);\n    case 'Number':\n      return FromNumber(schema_, references_);\n    case 'Object':\n      return FromObject(schema_, references_);\n    case 'Promise':\n      return FromPromise(schema_, references_);\n    case 'Record':\n      return FromRecord(schema_, references_);\n    case 'Ref':\n      return FromRef(schema_, references_);\n    case 'RegExp':\n      return FromRegExp(schema_, references_);\n    case 'String':\n      return FromString(schema_, references_);\n    case 'Symbol':\n      return FromSymbol(schema_, references_);\n    case 'TemplateLiteral':\n      return FromTemplateLiteral(schema_, references_);\n    case 'This':\n      return FromThis(schema_, references_);\n    case 'Tuple':\n      return FromTuple(schema_, references_);\n    case 'Undefined':\n      return FromUndefined(schema_, references_);\n    case 'Union':\n      return FromUnion(schema_, references_);\n    case 'Uint8Array':\n      return FromUint8Array(schema_, references_);\n    case 'Unknown':\n      return FromUnknown(schema_, references_);\n    case 'Void':\n      return FromVoid(schema_, references_);\n    default:\n      if (!TypeRegistry.Has(schema_[Kind])) throw new ValueCreateError(schema_, 'Unknown type');\n      return FromKind(schema_, references_);\n  }\n}\n// ------------------------------------------------------------------\n// State\n// ------------------------------------------------------------------\nconst recursiveMaxDepth = 512;\nlet recursiveDepth = 0;\n/** Creates a value from the given schema */\nexport function Create(...args) {\n  recursiveDepth = 0;\n  return args.length === 2 ? Visit(args[0], args[1]) : Visit(args[0], []);\n}","map":{"version":3,"names":["HasPropertyKey","IsString","Check","Clone","Deref","TemplateLiteralGenerate","IsTemplateLiteralFinite","PatternStringExact","PatternNumberExact","TypeRegistry","Kind","TypeBoxError","ValueCreateError","constructor","schema","message","FromDefault","value","FromAny","references","default","FromArray","uniqueItems","minItems","undefined","Array","from","length","map","item","Visit","items","FromAsyncIterator","FromBigInt","BigInt","FromBoolean","FromConstructor","returns","isArray","key","val","Object","entries","self","FromDate","minimumTimestamp","Date","FromFunction","FromInteger","minimum","FromIntersect","allOf","reduce","acc","next","FromIterator","FromLiteral","const","FromNever","FromNot","FromNull","FromNumber","FromObject","required","Set","Acc","subschema","properties","has","FromPromise","Promise","resolve","FromRecord","keyPattern","valueSchema","patternProperties","propertyKeys","slice","split","FromRef","FromRegExp","FromString","pattern","format","minLength","join","FromSymbol","Symbol","for","FromTemplateLiteral","generated","FromThis","recursiveDepth","recursiveMaxDepth","FromTuple","_","index","FromUndefined","FromUnion","anyOf","Error","FromUint8Array","minByteLength","Uint8Array","FromUnknown","FromVoid","FromKind","references_","$id","schema_","Has","Create","args"],"sources":["C:/Users/ordon/ThetaFlowz_Cursor/node_modules/yahoo-finance2/node_modules/@sinclair/typebox/build/esm/value/create/create.mjs"],"sourcesContent":["import { HasPropertyKey, IsString } from '../guard/index.mjs';\nimport { Check } from '../check/index.mjs';\nimport { Clone } from '../clone/index.mjs';\nimport { Deref } from '../deref/index.mjs';\nimport { TemplateLiteralGenerate, IsTemplateLiteralFinite } from '../../type/template-literal/index.mjs';\nimport { PatternStringExact, PatternNumberExact } from '../../type/patterns/index.mjs';\nimport { TypeRegistry } from '../../type/registry/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValueCreateError extends TypeBoxError {\n    constructor(schema, message) {\n        super(message);\n        this.schema = schema;\n    }\n}\n// ------------------------------------------------------------------\n// Default\n// ------------------------------------------------------------------\nfunction FromDefault(value) {\n    return typeof value === 'function' ? value : Clone(value);\n}\n// ------------------------------------------------------------------\n// Create\n// ------------------------------------------------------------------\nfunction FromAny(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return {};\n    }\n}\nfunction FromArray(schema, references) {\n    if (schema.uniqueItems === true && !HasPropertyKey(schema, 'default')) {\n        throw new ValueCreateError(schema, 'Array with the uniqueItems constraint requires a default value');\n    }\n    else if ('contains' in schema && !HasPropertyKey(schema, 'default')) {\n        throw new ValueCreateError(schema, 'Array with the contains constraint requires a default value');\n    }\n    else if ('default' in schema) {\n        return FromDefault(schema.default);\n    }\n    else if (schema.minItems !== undefined) {\n        return Array.from({ length: schema.minItems }).map((item) => {\n            return Visit(schema.items, references);\n        });\n    }\n    else {\n        return [];\n    }\n}\nfunction FromAsyncIterator(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return (async function* () { })();\n    }\n}\nfunction FromBigInt(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return BigInt(0);\n    }\n}\nfunction FromBoolean(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return false;\n    }\n}\nfunction FromConstructor(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        const value = Visit(schema.returns, references);\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            return class {\n                constructor() {\n                    for (const [key, val] of Object.entries(value)) {\n                        const self = this;\n                        self[key] = val;\n                    }\n                }\n            };\n        }\n        else {\n            return class {\n            };\n        }\n    }\n}\nfunction FromDate(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else if (schema.minimumTimestamp !== undefined) {\n        return new Date(schema.minimumTimestamp);\n    }\n    else {\n        return new Date();\n    }\n}\nfunction FromFunction(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return () => Visit(schema.returns, references);\n    }\n}\nfunction FromInteger(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else if (schema.minimum !== undefined) {\n        return schema.minimum;\n    }\n    else {\n        return 0;\n    }\n}\nfunction FromIntersect(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        // --------------------------------------------------------------\n        // Note: The best we can do here is attempt to instance each\n        // sub type and apply through object assign. For non-object\n        // sub types, we just escape the assignment and just return\n        // the value. In the latter case, this is typically going to\n        // be a consequence of an illogical intersection.\n        // --------------------------------------------------------------\n        const value = schema.allOf.reduce((acc, schema) => {\n            const next = Visit(schema, references);\n            return typeof next === 'object' ? { ...acc, ...next } : next;\n        }, {});\n        if (!Check(schema, references, value))\n            throw new ValueCreateError(schema, 'Intersect produced invalid value. Consider using a default value.');\n        return value;\n    }\n}\nfunction FromIterator(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return (function* () { })();\n    }\n}\nfunction FromLiteral(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return schema.const;\n    }\n}\nfunction FromNever(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        throw new ValueCreateError(schema, 'Never types cannot be created. Consider using a default value.');\n    }\n}\nfunction FromNot(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        throw new ValueCreateError(schema, 'Not types must have a default value');\n    }\n}\nfunction FromNull(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return null;\n    }\n}\nfunction FromNumber(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else if (schema.minimum !== undefined) {\n        return schema.minimum;\n    }\n    else {\n        return 0;\n    }\n}\nfunction FromObject(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        const required = new Set(schema.required);\n        const Acc = {};\n        for (const [key, subschema] of Object.entries(schema.properties)) {\n            if (!required.has(key))\n                continue;\n            Acc[key] = Visit(subschema, references);\n        }\n        return Acc;\n    }\n}\nfunction FromPromise(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return Promise.resolve(Visit(schema.item, references));\n    }\n}\nfunction FromRecord(schema, references) {\n    const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {\n        const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split('|');\n        const Acc = {};\n        for (const key of propertyKeys)\n            Acc[key] = Visit(valueSchema, references);\n        return Acc;\n    }\n    else {\n        return {};\n    }\n}\nfunction FromRef(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return Visit(Deref(schema, references), references);\n    }\n}\nfunction FromRegExp(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        throw new ValueCreateError(schema, 'RegExp types cannot be created. Consider using a default value.');\n    }\n}\nfunction FromString(schema, references) {\n    if (schema.pattern !== undefined) {\n        if (!HasPropertyKey(schema, 'default')) {\n            throw new ValueCreateError(schema, 'String types with patterns must specify a default value');\n        }\n        else {\n            return FromDefault(schema.default);\n        }\n    }\n    else if (schema.format !== undefined) {\n        if (!HasPropertyKey(schema, 'default')) {\n            throw new ValueCreateError(schema, 'String types with formats must specify a default value');\n        }\n        else {\n            return FromDefault(schema.default);\n        }\n    }\n    else {\n        if (HasPropertyKey(schema, 'default')) {\n            return FromDefault(schema.default);\n        }\n        else if (schema.minLength !== undefined) {\n            // prettier-ignore\n            return Array.from({ length: schema.minLength }).map(() => ' ').join('');\n        }\n        else {\n            return '';\n        }\n    }\n}\nfunction FromSymbol(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else if ('value' in schema) {\n        return Symbol.for(schema.value);\n    }\n    else {\n        return Symbol();\n    }\n}\nfunction FromTemplateLiteral(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    if (!IsTemplateLiteralFinite(schema))\n        throw new ValueCreateError(schema, 'Can only create template literals that produce a finite variants. Consider using a default value.');\n    const generated = TemplateLiteralGenerate(schema);\n    return generated[0];\n}\nfunction FromThis(schema, references) {\n    if (recursiveDepth++ > recursiveMaxDepth)\n        throw new ValueCreateError(schema, 'Cannot create recursive type as it appears possibly infinite. Consider using a default.');\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return Visit(Deref(schema, references), references);\n    }\n}\nfunction FromTuple(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    if (schema.items === undefined) {\n        return [];\n    }\n    else {\n        return Array.from({ length: schema.minItems }).map((_, index) => Visit(schema.items[index], references));\n    }\n}\nfunction FromUndefined(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return undefined;\n    }\n}\nfunction FromUnion(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else if (schema.anyOf.length === 0) {\n        throw new Error('ValueCreate.Union: Cannot create Union with zero variants');\n    }\n    else {\n        return Visit(schema.anyOf[0], references);\n    }\n}\nfunction FromUint8Array(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else if (schema.minByteLength !== undefined) {\n        return new Uint8Array(schema.minByteLength);\n    }\n    else {\n        return new Uint8Array(0);\n    }\n}\nfunction FromUnknown(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return {};\n    }\n}\nfunction FromVoid(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return void 0;\n    }\n}\nfunction FromKind(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        throw new Error('User defined types must specify a default value');\n    }\n}\nfunction Visit(schema, references) {\n    const references_ = IsString(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[Kind]) {\n        case 'Any':\n            return FromAny(schema_, references_);\n        case 'Array':\n            return FromArray(schema_, references_);\n        case 'AsyncIterator':\n            return FromAsyncIterator(schema_, references_);\n        case 'BigInt':\n            return FromBigInt(schema_, references_);\n        case 'Boolean':\n            return FromBoolean(schema_, references_);\n        case 'Constructor':\n            return FromConstructor(schema_, references_);\n        case 'Date':\n            return FromDate(schema_, references_);\n        case 'Function':\n            return FromFunction(schema_, references_);\n        case 'Integer':\n            return FromInteger(schema_, references_);\n        case 'Intersect':\n            return FromIntersect(schema_, references_);\n        case 'Iterator':\n            return FromIterator(schema_, references_);\n        case 'Literal':\n            return FromLiteral(schema_, references_);\n        case 'Never':\n            return FromNever(schema_, references_);\n        case 'Not':\n            return FromNot(schema_, references_);\n        case 'Null':\n            return FromNull(schema_, references_);\n        case 'Number':\n            return FromNumber(schema_, references_);\n        case 'Object':\n            return FromObject(schema_, references_);\n        case 'Promise':\n            return FromPromise(schema_, references_);\n        case 'Record':\n            return FromRecord(schema_, references_);\n        case 'Ref':\n            return FromRef(schema_, references_);\n        case 'RegExp':\n            return FromRegExp(schema_, references_);\n        case 'String':\n            return FromString(schema_, references_);\n        case 'Symbol':\n            return FromSymbol(schema_, references_);\n        case 'TemplateLiteral':\n            return FromTemplateLiteral(schema_, references_);\n        case 'This':\n            return FromThis(schema_, references_);\n        case 'Tuple':\n            return FromTuple(schema_, references_);\n        case 'Undefined':\n            return FromUndefined(schema_, references_);\n        case 'Union':\n            return FromUnion(schema_, references_);\n        case 'Uint8Array':\n            return FromUint8Array(schema_, references_);\n        case 'Unknown':\n            return FromUnknown(schema_, references_);\n        case 'Void':\n            return FromVoid(schema_, references_);\n        default:\n            if (!TypeRegistry.Has(schema_[Kind]))\n                throw new ValueCreateError(schema_, 'Unknown type');\n            return FromKind(schema_, references_);\n    }\n}\n// ------------------------------------------------------------------\n// State\n// ------------------------------------------------------------------\nconst recursiveMaxDepth = 512;\nlet recursiveDepth = 0;\n/** Creates a value from the given schema */\nexport function Create(...args) {\n    recursiveDepth = 0;\n    return args.length === 2 ? Visit(args[0], args[1]) : Visit(args[0], []);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}