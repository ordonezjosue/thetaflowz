{"ast":null,"code":"import { TypeSystemPolicy } from '../../system/index.mjs';\nimport { Deref } from '../deref/index.mjs';\nimport { Hash } from '../hash/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\nimport { KeyOfPattern } from '../../type/keyof/index.mjs';\nimport { ExtendsUndefinedCheck } from '../../type/extends/index.mjs';\nimport { TypeRegistry, FormatRegistry } from '../../type/registry/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\nimport { Never } from '../../type/never/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsUint8Array, IsDate, IsPromise, IsFunction, IsAsyncIterator, IsIterator, IsBoolean, IsNumber, IsBigInt, IsString, IsSymbol, IsInteger, IsNull, IsUndefined } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsSchema } from '../../type/guard/type.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValueCheckUnknownTypeError extends TypeBoxError {\n  constructor(schema) {\n    super(`Unknown type`);\n    this.schema = schema;\n  }\n}\n// ------------------------------------------------------------------\n// TypeGuards\n// ------------------------------------------------------------------\nfunction IsAnyOrUnknown(schema) {\n  return schema[Kind] === 'Any' || schema[Kind] === 'Unknown';\n}\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nfunction IsDefined(value) {\n  return value !== undefined;\n}\n// ------------------------------------------------------------------\n// Types\n// ------------------------------------------------------------------\nfunction FromAny(schema, references, value) {\n  return true;\n}\nfunction FromArray(schema, references, value) {\n  if (!IsArray(value)) return false;\n  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n    return false;\n  }\n  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n    return false;\n  }\n  if (!value.every(value => Visit(schema.items, references, value))) {\n    return false;\n  }\n  // prettier-ignore\n  if (schema.uniqueItems === true && !function () {\n    const set = new Set();\n    for (const element of value) {\n      const hashed = Hash(element);\n      if (set.has(hashed)) {\n        return false;\n      } else {\n        set.add(hashed);\n      }\n    }\n    return true;\n  }()) {\n    return false;\n  }\n  // contains\n  if (!(IsDefined(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {\n    return true; // exit\n  }\n  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();\n  const containsCount = value.reduce((acc, value) => Visit(containsSchema, references, value) ? acc + 1 : acc, 0);\n  if (containsCount === 0) {\n    return false;\n  }\n  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {\n    return false;\n  }\n  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {\n    return false;\n  }\n  return true;\n}\nfunction FromAsyncIterator(schema, references, value) {\n  return IsAsyncIterator(value);\n}\nfunction FromBigInt(schema, references, value) {\n  if (!IsBigInt(value)) return false;\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    return false;\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    return false;\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    return false;\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    return false;\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n    return false;\n  }\n  return true;\n}\nfunction FromBoolean(schema, references, value) {\n  return IsBoolean(value);\n}\nfunction FromConstructor(schema, references, value) {\n  return Visit(schema.returns, references, value.prototype);\n}\nfunction FromDate(schema, references, value) {\n  if (!IsDate(value)) return false;\n  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n    return false;\n  }\n  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n    return false;\n  }\n  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n    return false;\n  }\n  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n    return false;\n  }\n  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n    return false;\n  }\n  return true;\n}\nfunction FromFunction(schema, references, value) {\n  return IsFunction(value);\n}\nfunction FromInteger(schema, references, value) {\n  if (!IsInteger(value)) {\n    return false;\n  }\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    return false;\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    return false;\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    return false;\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    return false;\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n    return false;\n  }\n  return true;\n}\nfunction FromIntersect(schema, references, value) {\n  const check1 = schema.allOf.every(schema => Visit(schema, references, value));\n  if (schema.unevaluatedProperties === false) {\n    const keyPattern = new RegExp(KeyOfPattern(schema));\n    const check2 = Object.getOwnPropertyNames(value).every(key => keyPattern.test(key));\n    return check1 && check2;\n  } else if (IsSchema(schema.unevaluatedProperties)) {\n    const keyCheck = new RegExp(KeyOfPattern(schema));\n    const check2 = Object.getOwnPropertyNames(value).every(key => keyCheck.test(key) || Visit(schema.unevaluatedProperties, references, value[key]));\n    return check1 && check2;\n  } else {\n    return check1;\n  }\n}\nfunction FromIterator(schema, references, value) {\n  return IsIterator(value);\n}\nfunction FromLiteral(schema, references, value) {\n  return value === schema.const;\n}\nfunction FromNever(schema, references, value) {\n  return false;\n}\nfunction FromNot(schema, references, value) {\n  return !Visit(schema.not, references, value);\n}\nfunction FromNull(schema, references, value) {\n  return IsNull(value);\n}\nfunction FromNumber(schema, references, value) {\n  if (!TypeSystemPolicy.IsNumberLike(value)) return false;\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    return false;\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    return false;\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    return false;\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    return false;\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n    return false;\n  }\n  return true;\n}\nfunction FromObject(schema, references, value) {\n  if (!TypeSystemPolicy.IsObjectLike(value)) return false;\n  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n    return false;\n  }\n  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n    return false;\n  }\n  const knownKeys = Object.getOwnPropertyNames(schema.properties);\n  for (const knownKey of knownKeys) {\n    const property = schema.properties[knownKey];\n    if (schema.required && schema.required.includes(knownKey)) {\n      if (!Visit(property, references, value[knownKey])) {\n        return false;\n      }\n      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {\n        return false;\n      }\n    } else {\n      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) {\n        return false;\n      }\n    }\n  }\n  if (schema.additionalProperties === false) {\n    const valueKeys = Object.getOwnPropertyNames(value);\n    // optimization: value is valid if schemaKey length matches the valueKey length\n    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {\n      return true;\n    } else {\n      return valueKeys.every(valueKey => knownKeys.includes(valueKey));\n    }\n  } else if (typeof schema.additionalProperties === 'object') {\n    const valueKeys = Object.getOwnPropertyNames(value);\n    return valueKeys.every(key => knownKeys.includes(key) || Visit(schema.additionalProperties, references, value[key]));\n  } else {\n    return true;\n  }\n}\nfunction FromPromise(schema, references, value) {\n  return IsPromise(value);\n}\nfunction FromRecord(schema, references, value) {\n  if (!TypeSystemPolicy.IsRecordLike(value)) {\n    return false;\n  }\n  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n    return false;\n  }\n  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n    return false;\n  }\n  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n  const regex = new RegExp(patternKey);\n  // prettier-ignore\n  const check1 = Object.entries(value).every(([key, value]) => {\n    return regex.test(key) ? Visit(patternSchema, references, value) : true;\n  });\n  // prettier-ignore\n  const check2 = typeof schema.additionalProperties === 'object' ? Object.entries(value).every(([key, value]) => {\n    return !regex.test(key) ? Visit(schema.additionalProperties, references, value) : true;\n  }) : true;\n  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every(key => {\n    return regex.test(key);\n  }) : true;\n  return check1 && check2 && check3;\n}\nfunction FromRef(schema, references, value) {\n  return Visit(Deref(schema, references), references, value);\n}\nfunction FromRegExp(schema, references, value) {\n  const regex = new RegExp(schema.source, schema.flags);\n  if (IsDefined(schema.minLength)) {\n    if (!(value.length >= schema.minLength)) return false;\n  }\n  if (IsDefined(schema.maxLength)) {\n    if (!(value.length <= schema.maxLength)) return false;\n  }\n  return regex.test(value);\n}\nfunction FromString(schema, references, value) {\n  if (!IsString(value)) {\n    return false;\n  }\n  if (IsDefined(schema.minLength)) {\n    if (!(value.length >= schema.minLength)) return false;\n  }\n  if (IsDefined(schema.maxLength)) {\n    if (!(value.length <= schema.maxLength)) return false;\n  }\n  if (IsDefined(schema.pattern)) {\n    const regex = new RegExp(schema.pattern);\n    if (!regex.test(value)) return false;\n  }\n  if (IsDefined(schema.format)) {\n    if (!FormatRegistry.Has(schema.format)) return false;\n    const func = FormatRegistry.Get(schema.format);\n    return func(value);\n  }\n  return true;\n}\nfunction FromSymbol(schema, references, value) {\n  return IsSymbol(value);\n}\nfunction FromTemplateLiteral(schema, references, value) {\n  return IsString(value) && new RegExp(schema.pattern).test(value);\n}\nfunction FromThis(schema, references, value) {\n  return Visit(Deref(schema, references), references, value);\n}\nfunction FromTuple(schema, references, value) {\n  if (!IsArray(value)) {\n    return false;\n  }\n  if (schema.items === undefined && !(value.length === 0)) {\n    return false;\n  }\n  if (!(value.length === schema.maxItems)) {\n    return false;\n  }\n  if (!schema.items) {\n    return true;\n  }\n  for (let i = 0; i < schema.items.length; i++) {\n    if (!Visit(schema.items[i], references, value[i])) return false;\n  }\n  return true;\n}\nfunction FromUndefined(schema, references, value) {\n  return IsUndefined(value);\n}\nfunction FromUnion(schema, references, value) {\n  return schema.anyOf.some(inner => Visit(inner, references, value));\n}\nfunction FromUint8Array(schema, references, value) {\n  if (!IsUint8Array(value)) {\n    return false;\n  }\n  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n    return false;\n  }\n  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n    return false;\n  }\n  return true;\n}\nfunction FromUnknown(schema, references, value) {\n  return true;\n}\nfunction FromVoid(schema, references, value) {\n  return TypeSystemPolicy.IsVoidLike(value);\n}\nfunction FromKind(schema, references, value) {\n  if (!TypeRegistry.Has(schema[Kind])) return false;\n  const func = TypeRegistry.Get(schema[Kind]);\n  return func(schema, value);\n}\nfunction Visit(schema, references, value) {\n  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n  const schema_ = schema;\n  switch (schema_[Kind]) {\n    case 'Any':\n      return FromAny(schema_, references_, value);\n    case 'Array':\n      return FromArray(schema_, references_, value);\n    case 'AsyncIterator':\n      return FromAsyncIterator(schema_, references_, value);\n    case 'BigInt':\n      return FromBigInt(schema_, references_, value);\n    case 'Boolean':\n      return FromBoolean(schema_, references_, value);\n    case 'Constructor':\n      return FromConstructor(schema_, references_, value);\n    case 'Date':\n      return FromDate(schema_, references_, value);\n    case 'Function':\n      return FromFunction(schema_, references_, value);\n    case 'Integer':\n      return FromInteger(schema_, references_, value);\n    case 'Intersect':\n      return FromIntersect(schema_, references_, value);\n    case 'Iterator':\n      return FromIterator(schema_, references_, value);\n    case 'Literal':\n      return FromLiteral(schema_, references_, value);\n    case 'Never':\n      return FromNever(schema_, references_, value);\n    case 'Not':\n      return FromNot(schema_, references_, value);\n    case 'Null':\n      return FromNull(schema_, references_, value);\n    case 'Number':\n      return FromNumber(schema_, references_, value);\n    case 'Object':\n      return FromObject(schema_, references_, value);\n    case 'Promise':\n      return FromPromise(schema_, references_, value);\n    case 'Record':\n      return FromRecord(schema_, references_, value);\n    case 'Ref':\n      return FromRef(schema_, references_, value);\n    case 'RegExp':\n      return FromRegExp(schema_, references_, value);\n    case 'String':\n      return FromString(schema_, references_, value);\n    case 'Symbol':\n      return FromSymbol(schema_, references_, value);\n    case 'TemplateLiteral':\n      return FromTemplateLiteral(schema_, references_, value);\n    case 'This':\n      return FromThis(schema_, references_, value);\n    case 'Tuple':\n      return FromTuple(schema_, references_, value);\n    case 'Undefined':\n      return FromUndefined(schema_, references_, value);\n    case 'Union':\n      return FromUnion(schema_, references_, value);\n    case 'Uint8Array':\n      return FromUint8Array(schema_, references_, value);\n    case 'Unknown':\n      return FromUnknown(schema_, references_, value);\n    case 'Void':\n      return FromVoid(schema_, references_, value);\n    default:\n      if (!TypeRegistry.Has(schema_[Kind])) throw new ValueCheckUnknownTypeError(schema_);\n      return FromKind(schema_, references_, value);\n  }\n}\n/** Returns true if the value matches the given type. */\nexport function Check(...args) {\n  return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}","map":{"version":3,"names":["TypeSystemPolicy","Deref","Hash","Kind","KeyOfPattern","ExtendsUndefinedCheck","TypeRegistry","FormatRegistry","TypeBoxError","Never","IsArray","IsUint8Array","IsDate","IsPromise","IsFunction","IsAsyncIterator","IsIterator","IsBoolean","IsNumber","IsBigInt","IsString","IsSymbol","IsInteger","IsNull","IsUndefined","IsSchema","ValueCheckUnknownTypeError","constructor","schema","IsAnyOrUnknown","IsDefined","value","undefined","FromAny","references","FromArray","minItems","length","maxItems","every","Visit","items","uniqueItems","set","Set","element","hashed","has","add","contains","minContains","maxContains","containsSchema","containsCount","reduce","acc","FromAsyncIterator","FromBigInt","exclusiveMaximum","exclusiveMinimum","maximum","minimum","multipleOf","BigInt","FromBoolean","FromConstructor","returns","prototype","FromDate","exclusiveMaximumTimestamp","getTime","exclusiveMinimumTimestamp","maximumTimestamp","minimumTimestamp","multipleOfTimestamp","FromFunction","FromInteger","FromIntersect","check1","allOf","unevaluatedProperties","keyPattern","RegExp","check2","Object","getOwnPropertyNames","key","test","keyCheck","FromIterator","FromLiteral","const","FromNever","FromNot","not","FromNull","FromNumber","IsNumberLike","FromObject","IsObjectLike","minProperties","maxProperties","knownKeys","properties","knownKey","property","required","includes","IsExactOptionalProperty","additionalProperties","valueKeys","valueKey","FromPromise","FromRecord","IsRecordLike","patternKey","patternSchema","entries","patternProperties","regex","check3","FromRef","FromRegExp","source","flags","minLength","maxLength","FromString","pattern","format","Has","func","Get","FromSymbol","FromTemplateLiteral","FromThis","FromTuple","i","FromUndefined","FromUnion","anyOf","some","inner","FromUint8Array","maxByteLength","minByteLength","FromUnknown","FromVoid","IsVoidLike","FromKind","references_","$id","schema_","Check","args"],"sources":["C:/Users/ordon/ThetaFlowz_Cursor/node_modules/yahoo-finance2/node_modules/@sinclair/typebox/build/esm/value/check/check.mjs"],"sourcesContent":["import { TypeSystemPolicy } from '../../system/index.mjs';\nimport { Deref } from '../deref/index.mjs';\nimport { Hash } from '../hash/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\nimport { KeyOfPattern } from '../../type/keyof/index.mjs';\nimport { ExtendsUndefinedCheck } from '../../type/extends/index.mjs';\nimport { TypeRegistry, FormatRegistry } from '../../type/registry/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\nimport { Never } from '../../type/never/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsUint8Array, IsDate, IsPromise, IsFunction, IsAsyncIterator, IsIterator, IsBoolean, IsNumber, IsBigInt, IsString, IsSymbol, IsInteger, IsNull, IsUndefined } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsSchema } from '../../type/guard/type.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValueCheckUnknownTypeError extends TypeBoxError {\n    constructor(schema) {\n        super(`Unknown type`);\n        this.schema = schema;\n    }\n}\n// ------------------------------------------------------------------\n// TypeGuards\n// ------------------------------------------------------------------\nfunction IsAnyOrUnknown(schema) {\n    return schema[Kind] === 'Any' || schema[Kind] === 'Unknown';\n}\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nfunction IsDefined(value) {\n    return value !== undefined;\n}\n// ------------------------------------------------------------------\n// Types\n// ------------------------------------------------------------------\nfunction FromAny(schema, references, value) {\n    return true;\n}\nfunction FromArray(schema, references, value) {\n    if (!IsArray(value))\n        return false;\n    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n        return false;\n    }\n    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n        return false;\n    }\n    if (!value.every((value) => Visit(schema.items, references, value))) {\n        return false;\n    }\n    // prettier-ignore\n    if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {\n        const hashed = Hash(element);\n        if (set.has(hashed)) {\n            return false;\n        }\n        else {\n            set.add(hashed);\n        }\n    } return true; })())) {\n        return false;\n    }\n    // contains\n    if (!(IsDefined(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {\n        return true; // exit\n    }\n    const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();\n    const containsCount = value.reduce((acc, value) => (Visit(containsSchema, references, value) ? acc + 1 : acc), 0);\n    if (containsCount === 0) {\n        return false;\n    }\n    if (IsNumber(schema.minContains) && containsCount < schema.minContains) {\n        return false;\n    }\n    if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {\n        return false;\n    }\n    return true;\n}\nfunction FromAsyncIterator(schema, references, value) {\n    return IsAsyncIterator(value);\n}\nfunction FromBigInt(schema, references, value) {\n    if (!IsBigInt(value))\n        return false;\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        return false;\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        return false;\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n        return false;\n    }\n    return true;\n}\nfunction FromBoolean(schema, references, value) {\n    return IsBoolean(value);\n}\nfunction FromConstructor(schema, references, value) {\n    return Visit(schema.returns, references, value.prototype);\n}\nfunction FromDate(schema, references, value) {\n    if (!IsDate(value))\n        return false;\n    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n        return false;\n    }\n    return true;\n}\nfunction FromFunction(schema, references, value) {\n    return IsFunction(value);\n}\nfunction FromInteger(schema, references, value) {\n    if (!IsInteger(value)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        return false;\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        return false;\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        return false;\n    }\n    return true;\n}\nfunction FromIntersect(schema, references, value) {\n    const check1 = schema.allOf.every((schema) => Visit(schema, references, value));\n    if (schema.unevaluatedProperties === false) {\n        const keyPattern = new RegExp(KeyOfPattern(schema));\n        const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));\n        return check1 && check2;\n    }\n    else if (IsSchema(schema.unevaluatedProperties)) {\n        const keyCheck = new RegExp(KeyOfPattern(schema));\n        const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit(schema.unevaluatedProperties, references, value[key]));\n        return check1 && check2;\n    }\n    else {\n        return check1;\n    }\n}\nfunction FromIterator(schema, references, value) {\n    return IsIterator(value);\n}\nfunction FromLiteral(schema, references, value) {\n    return value === schema.const;\n}\nfunction FromNever(schema, references, value) {\n    return false;\n}\nfunction FromNot(schema, references, value) {\n    return !Visit(schema.not, references, value);\n}\nfunction FromNull(schema, references, value) {\n    return IsNull(value);\n}\nfunction FromNumber(schema, references, value) {\n    if (!TypeSystemPolicy.IsNumberLike(value))\n        return false;\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        return false;\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        return false;\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        return false;\n    }\n    return true;\n}\nfunction FromObject(schema, references, value) {\n    if (!TypeSystemPolicy.IsObjectLike(value))\n        return false;\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        return false;\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        return false;\n    }\n    const knownKeys = Object.getOwnPropertyNames(schema.properties);\n    for (const knownKey of knownKeys) {\n        const property = schema.properties[knownKey];\n        if (schema.required && schema.required.includes(knownKey)) {\n            if (!Visit(property, references, value[knownKey])) {\n                return false;\n            }\n            if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {\n                return false;\n            }\n        }\n        else {\n            if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) {\n                return false;\n            }\n        }\n    }\n    if (schema.additionalProperties === false) {\n        const valueKeys = Object.getOwnPropertyNames(value);\n        // optimization: value is valid if schemaKey length matches the valueKey length\n        if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {\n            return true;\n        }\n        else {\n            return valueKeys.every((valueKey) => knownKeys.includes(valueKey));\n        }\n    }\n    else if (typeof schema.additionalProperties === 'object') {\n        const valueKeys = Object.getOwnPropertyNames(value);\n        return valueKeys.every((key) => knownKeys.includes(key) || Visit(schema.additionalProperties, references, value[key]));\n    }\n    else {\n        return true;\n    }\n}\nfunction FromPromise(schema, references, value) {\n    return IsPromise(value);\n}\nfunction FromRecord(schema, references, value) {\n    if (!TypeSystemPolicy.IsRecordLike(value)) {\n        return false;\n    }\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        return false;\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        return false;\n    }\n    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n    const regex = new RegExp(patternKey);\n    // prettier-ignore\n    const check1 = Object.entries(value).every(([key, value]) => {\n        return (regex.test(key)) ? Visit(patternSchema, references, value) : true;\n    });\n    // prettier-ignore\n    const check2 = typeof schema.additionalProperties === 'object' ? Object.entries(value).every(([key, value]) => {\n        return (!regex.test(key)) ? Visit(schema.additionalProperties, references, value) : true;\n    }) : true;\n    const check3 = schema.additionalProperties === false\n        ? Object.getOwnPropertyNames(value).every((key) => {\n            return regex.test(key);\n        })\n        : true;\n    return check1 && check2 && check3;\n}\nfunction FromRef(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromRegExp(schema, references, value) {\n    const regex = new RegExp(schema.source, schema.flags);\n    if (IsDefined(schema.minLength)) {\n        if (!(value.length >= schema.minLength))\n            return false;\n    }\n    if (IsDefined(schema.maxLength)) {\n        if (!(value.length <= schema.maxLength))\n            return false;\n    }\n    return regex.test(value);\n}\nfunction FromString(schema, references, value) {\n    if (!IsString(value)) {\n        return false;\n    }\n    if (IsDefined(schema.minLength)) {\n        if (!(value.length >= schema.minLength))\n            return false;\n    }\n    if (IsDefined(schema.maxLength)) {\n        if (!(value.length <= schema.maxLength))\n            return false;\n    }\n    if (IsDefined(schema.pattern)) {\n        const regex = new RegExp(schema.pattern);\n        if (!regex.test(value))\n            return false;\n    }\n    if (IsDefined(schema.format)) {\n        if (!FormatRegistry.Has(schema.format))\n            return false;\n        const func = FormatRegistry.Get(schema.format);\n        return func(value);\n    }\n    return true;\n}\nfunction FromSymbol(schema, references, value) {\n    return IsSymbol(value);\n}\nfunction FromTemplateLiteral(schema, references, value) {\n    return IsString(value) && new RegExp(schema.pattern).test(value);\n}\nfunction FromThis(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromTuple(schema, references, value) {\n    if (!IsArray(value)) {\n        return false;\n    }\n    if (schema.items === undefined && !(value.length === 0)) {\n        return false;\n    }\n    if (!(value.length === schema.maxItems)) {\n        return false;\n    }\n    if (!schema.items) {\n        return true;\n    }\n    for (let i = 0; i < schema.items.length; i++) {\n        if (!Visit(schema.items[i], references, value[i]))\n            return false;\n    }\n    return true;\n}\nfunction FromUndefined(schema, references, value) {\n    return IsUndefined(value);\n}\nfunction FromUnion(schema, references, value) {\n    return schema.anyOf.some((inner) => Visit(inner, references, value));\n}\nfunction FromUint8Array(schema, references, value) {\n    if (!IsUint8Array(value)) {\n        return false;\n    }\n    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n        return false;\n    }\n    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n        return false;\n    }\n    return true;\n}\nfunction FromUnknown(schema, references, value) {\n    return true;\n}\nfunction FromVoid(schema, references, value) {\n    return TypeSystemPolicy.IsVoidLike(value);\n}\nfunction FromKind(schema, references, value) {\n    if (!TypeRegistry.Has(schema[Kind]))\n        return false;\n    const func = TypeRegistry.Get(schema[Kind]);\n    return func(schema, value);\n}\nfunction Visit(schema, references, value) {\n    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[Kind]) {\n        case 'Any':\n            return FromAny(schema_, references_, value);\n        case 'Array':\n            return FromArray(schema_, references_, value);\n        case 'AsyncIterator':\n            return FromAsyncIterator(schema_, references_, value);\n        case 'BigInt':\n            return FromBigInt(schema_, references_, value);\n        case 'Boolean':\n            return FromBoolean(schema_, references_, value);\n        case 'Constructor':\n            return FromConstructor(schema_, references_, value);\n        case 'Date':\n            return FromDate(schema_, references_, value);\n        case 'Function':\n            return FromFunction(schema_, references_, value);\n        case 'Integer':\n            return FromInteger(schema_, references_, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, value);\n        case 'Iterator':\n            return FromIterator(schema_, references_, value);\n        case 'Literal':\n            return FromLiteral(schema_, references_, value);\n        case 'Never':\n            return FromNever(schema_, references_, value);\n        case 'Not':\n            return FromNot(schema_, references_, value);\n        case 'Null':\n            return FromNull(schema_, references_, value);\n        case 'Number':\n            return FromNumber(schema_, references_, value);\n        case 'Object':\n            return FromObject(schema_, references_, value);\n        case 'Promise':\n            return FromPromise(schema_, references_, value);\n        case 'Record':\n            return FromRecord(schema_, references_, value);\n        case 'Ref':\n            return FromRef(schema_, references_, value);\n        case 'RegExp':\n            return FromRegExp(schema_, references_, value);\n        case 'String':\n            return FromString(schema_, references_, value);\n        case 'Symbol':\n            return FromSymbol(schema_, references_, value);\n        case 'TemplateLiteral':\n            return FromTemplateLiteral(schema_, references_, value);\n        case 'This':\n            return FromThis(schema_, references_, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, value);\n        case 'Undefined':\n            return FromUndefined(schema_, references_, value);\n        case 'Union':\n            return FromUnion(schema_, references_, value);\n        case 'Uint8Array':\n            return FromUint8Array(schema_, references_, value);\n        case 'Unknown':\n            return FromUnknown(schema_, references_, value);\n        case 'Void':\n            return FromVoid(schema_, references_, value);\n        default:\n            if (!TypeRegistry.Has(schema_[Kind]))\n                throw new ValueCheckUnknownTypeError(schema_);\n            return FromKind(schema_, references_, value);\n    }\n}\n/** Returns true if the value matches the given type. */\nexport function Check(...args) {\n    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}